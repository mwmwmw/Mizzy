{"version":3,"names":[],"mappings":"","sources":["mizzy.js"],"sourcesContent":["(function (exports) {\n'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar midinotes = {\n    \"C\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n    \"D\": [2, 14, 26, 38, 50, 62, 74, 86, 98, 110, 122],\n    \"E\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n    \"F\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n    \"G\": [7, 19, 31, 43, 55, 67, 79, 91, 103, 115, 127],\n    \"A\": [9, 21, 33, 45, 57, 69, 81, 93, 105, 117],\n    \"B\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119],\n    \"C#\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n    \"D#\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n    \"E#\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n    \"F#\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n    \"G#\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n    \"A#\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n    \"B#\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n    \"Db\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n    \"Eb\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n    \"Fb\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n    \"Gb\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n    \"Ab\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n    \"Bb\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n    \"Cb\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119]\n};\n\nvar noteon = 0x90;\nvar noteoff = 0x80;\nvar aftertouch = 0xA0;\nvar controlchange = 0xB0;\nvar programchange = 0xC0;\nvar channelpressure = 0xD0;\nvar pitchbend = 0xE0;\n\nvar MIDIData = function () {\n    function MIDIData() {\n        classCallCheck(this, MIDIData);\n    }\n\n    createClass(MIDIData, null, [{\n        key: \"MidiNotes\",\n        get: function get$$1() {\n            return midinotes;\n        }\n    }, {\n        key: \"NoteOff\",\n        get: function get$$1() {\n            return noteoff;\n        }\n    }, {\n        key: \"NoteOn\",\n        get: function get$$1() {\n            return noteon;\n        }\n    }, {\n        key: \"AfterTouch\",\n        get: function get$$1() {\n            return aftertouch;\n        }\n    }, {\n        key: \"ControlChange\",\n        get: function get$$1() {\n            return controlchange;\n        }\n    }, {\n        key: \"ProgramChange\",\n        get: function get$$1() {\n            return programchange;\n        }\n    }, {\n        key: \"ChannelPressure\",\n        get: function get$$1() {\n            return channelpressure;\n        }\n    }, {\n        key: \"PitchBend\",\n        get: function get$$1() {\n            return pitchbend;\n        }\n    }]);\n    return MIDIData;\n}();\n\nvar accidentals = {\n    \"C\": \"#\",\n    \"G\": \"#\",\n    \"D\": \"#\",\n    \"A\": \"#\",\n    \"E\": \"#\",\n    \"B\": \"#\",\n    \"Cb\": \"b\",\n    \"F#\": \"#\",\n    \"Gb\": \"b\",\n    \"C#\": \"#\",\n    \"Db\": \"b\",\n    \"Ab\": \"b\",\n    \"Eb\": \"b\",\n    \"Bb\": \"b\",\n    \"F\": \"b\"\n};\n\nvar keynotes$1 = {\n    \"C\": [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"],\n    \"G\": [\"G\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F#\"],\n    \"D\": [\"D\", \"E\", \"F#\", \"G\", \"A\", \"B\", \"C#\"],\n    \"A\": [\"A\", \"B\", \"C#\", \"D\", \"E\", \"F#\", \"G#\"],\n    \"E\": [\"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D#\"],\n    \"B\": [\"B\", \"C#\", \"D#\", \"E\", \"F#\", \"G#\", \"A#\"],\n    \"F#\": [\"F#\", \"G#\", \"A#\", \"B\", \"C#\", \"D#\", \"E#\"],\n    \"C#\": [\"C#\", \"D#\", \"E#\", \"F#\", \"G#\", \"A#\", \"B#\"],\n    \"Cb\": [\"Cb\", \"Db\", \"Eb\", \"Fb\", \"Gb\", \"Ab\", \"Bb\"],\n    \"Gb\": [\"Gb\", \"Ab\", \"Bb\", \"Cb\", \"Db\", \"Eb\", \"F\"],\n    \"Db\": [\"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\", \"Bb\", \"C\"],\n    \"Ab\": [\"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"G\"],\n    \"Eb\": [\"Eb\", \"F\", \"G\", \"Ab\", \"Bb\", \"C\", \"D\"],\n    \"Bb\": [\"Bb\", \"C\", \"D\", \"Eb\", \"F\", \"G\", \"A\"],\n    \"F\": [\"F\", \"G\", \"A\", \"Bb\", \"C\", \"D\", \"E\"]\n};\n\nvar keys = [\"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"Cb\", \"F#\", \"Gb\", \"C#\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\"];\n\nvar Notation = function () {\n    function Notation() {\n        classCallCheck(this, Notation);\n    }\n\n    createClass(Notation, null, [{\n        key: \"Keys\",\n        get: function get$$1() {\n            return keys;\n        }\n    }, {\n        key: \"KeyNotes\",\n        get: function get$$1() {\n            return keynotes$1;\n        }\n    }, {\n        key: \"Accidentals\",\n        get: function get$$1() {\n            return accidentals;\n        }\n    }]);\n    return Notation;\n}();\n\nvar Generate = function () {\n    function Generate() {\n        classCallCheck(this, Generate);\n    }\n\n    createClass(Generate, null, [{\n        key: \"NoteOn\",\n        value: function NoteOn(noteNumber, velocity) {\n            new Uint8Array([MIDIData.NoteOn, noteNumber, velocity]);\n        }\n    }, {\n        key: \"NoteOff\",\n        value: function NoteOff(noteNumber, velocity) {\n            new Uint8Array([MIDIData.NoteOff, noteNumber, velocity]);\n        }\n    }, {\n        key: \"AfterTouch\",\n        value: function AfterTouch(noteNumber, value) {\n            new Uint8Array([MIDIData.AfterTouch, noteNumber, value]);\n        }\n    }, {\n        key: \"ControlChange\",\n        value: function ControlChange(controller, value) {\n            new Uint8Array([MIDIData.ControlChange, controller, value]);\n        }\n    }, {\n        key: \"ProgramChange\",\n        value: function ProgramChange(instrument) {\n            new Uint8Array([MIDIData.ProgramChange, instrument]);\n        }\n    }, {\n        key: \"ChannelPressure\",\n        value: function ChannelPressure(pressure) {\n            new Uint8Array([MIDIData.ChannelPressure, pressure]);\n        }\n    }, {\n        key: \"PitchBend\",\n        value: function PitchBend(value) {\n            // @todo http://stackoverflow.com/questions/30911185/javascript-reading-3-bytes-buffer-as-an-integer\n            var msb = 1,\n                lsb = 1;\n            new Uint8Array([MIDIData.ChannelPressure, msb, lsb]);\n        }\n    }]);\n    return Generate;\n}();\n\nvar notes = MIDIData.MidiNotes;\n\nvar NoteProcessor = function () {\n\tfunction NoteProcessor() {\n\t\tclassCallCheck(this, NoteProcessor);\n\t}\n\n\tcreateClass(NoteProcessor, null, [{\n\t\tkey: \"processNoteEvent\",\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function processNoteEvent(message, messageType) {\n\t\t\tvar notes = this.getNoteNames(message.data[1]);\n\t\t\tvar data = {\n\t\t\t\t\"enharmonics\": notes,\n\t\t\t\t\"note\": this.findNoteInKey(notes, this.key),\n\t\t\t\t\"inKey\": this.isNoteInKey(notes, this.key),\n\t\t\t\t\"value\": message.data[1],\n\t\t\t\t\"velocity\": message.data[2],\n\t\t\t\t\"frequency\": 440 * Math.pow(2, (message.data[1] - 69) / 12)\n\t\t\t};\n\t\t\tswitch (messageType) {\n\t\t\t\tcase \"NoteOn\":\n\t\t\t\t\tthis.keysPressed[message.data[1]] = data;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"NoteOff\":\n\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\treturn Object.assign(message, data);\n\t\t}\n\t}, {\n\t\tkey: \"processCCEvent\",\n\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function processCCEvent(message, ccNameOverride) {\n\t\t\tObject.assign(message, {\n\t\t\t\t\"cc\": ccNameOverride || message.data[1],\n\t\t\t\t\"value\": message.data[2],\n\t\t\t\t\"ratio\": message.data[2] / 127,\n\t\t\t\t\"timestamp\": message.receivedTime\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"processMidiControlEvent\",\n\t\tvalue: function processMidiControlEvent(message, controlName) {\n\t\t\tObject.assign(message, {\n\t\t\t\t\"cc\": controlName,\n\t\t\t\t\"value\": message.data[1],\n\t\t\t\t\"ratio\": message.data[1] / 127,\n\t\t\t\t\"timestamp\": message.receivedTime\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"processPitchWheel\",\n\t\tvalue: function processPitchWheel(message) {\n\t\t\tvar raw = message.data[1] | message.data[2] << 7,\n\t\t\t    calc = -(8192 - raw),\n\t\t\t    ratio = calc / 8192;\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": \"pitchwheel\",\n\t\t\t\t\"value\": raw,\n\t\t\t\t\"polar\": calc,\n\t\t\t\t\"polarRatio\": ratio,\n\t\t\t\t\"timestamp\": message.receivedTime\n\t\t\t});\n\t\t}\n\n\t\t// process the midi message. Go through each type and add processed data\n\t\t// when done, check for any bound events and run them.\n\n\t\t// get a list of notes that match this noteNumber\n\n\t}, {\n\t\tkey: \"getNoteNames\",\n\t\tvalue: function getNoteNames(noteNumber) {\n\t\t\tvar noteNames = []; // create a list for the notes\n\t\t\tfor (var note in notes) {\n\t\t\t\t// loop through the note table and push notes that match.\n\t\t\t\tnotes[note].forEach(function (keynumber) {\n\t\t\t\t\tif (noteNumber === keynumber) {\n\t\t\t\t\t\tnoteNames.push(note);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn noteNames;\n\t\t}\n\t}, {\n\t\tkey: \"findNoteInKey\",\n\n\n\t\t// find the first note that is in the current key\n\t\tvalue: function findNoteInKey(notes, key) {\n\t\t\t// loop through the note list\n\t\t\tfor (var i = 0; i < notes.length; i++) {\n\t\t\t\tvar note = notes[i];\n\t\t\t\tif (this.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn note;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn notes[0];\n\t\t}\n\t}, {\n\t\tkey: \"isNoteInKey\",\n\n\n\t\t// is this note in key\n\t\tvalue: function isNoteInKey(notes, key) {\n\t\t\tfor (var n = 0; n < notes.length; n++) {\n\t\t\t\tvar note = notes[n];\n\t\t\t\tif (this.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"matchNoteInKey\",\n\t\tvalue: function matchNoteInKey(note, key) {\n\t\t\tfor (var i = 0; i < keynotes[key].length; i++) {\n\t\t\t\tvar keynote = keynotes[key][i];\n\t\t\t\tif (note === keynote) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// this.findAccidental = function(notes, key) {\n\t\t//     // are there any enharmonic equivalents\n\t\t//     if (notes.length > 1) {\n\t\t//         // check to see if the first note has an accidental (indicates you're on a black key);\n\t\t//         if(notes[0].length > 1) {\n\t\t//             for (var i = 0; i < notes.length; i++) {\n\t\t//                 var note = notes[i];\n\t\t//                 // does this note match the note in key\n\t\t//                 if (note[note.length - 1] === this.accidentals[key]) {\n\t\t//                     return note;\n\t\t//                 }\n\t\t//             }\n\t\t//             return notes[0];\n\t\t//         } else {\n\t\t//             return notes[0];\n\t\t//         }\n\t\t//     } else {\n\t\t//         return notes[0];\n\t\t//     }\n\t\t// };\n\n\t}]);\n\treturn NoteProcessor;\n}();\n\nvar listeners = {};\n\nvar Events = function () {\n\tfunction Events() {\n\t\tclassCallCheck(this, Events);\n\t}\n\n\tcreateClass(Events, null, [{\n\t\tkey: \"on\",\n\n\t\t// take this event name, and run this handler when it occurs\n\t\tvalue: function on(event, handler) {\n\t\t\tif (listeners[event] === undefined) {\n\t\t\t\tlisteners[event] = [handler];\n\t\t\t} else {\n\t\t\t\tlisteners[event].push(handler);\n\t\t\t}\n\t\t\treturn handler;\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\n\n\t\t// unbind this event and handler\n\t\tvalue: function off(event, handler) {\n\t\t\tif (listeners[event]) {\n\t\t\t\tfor (var i = listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\tif (listeners[event].length === 1) {\n\t\t\t\t\t\tdelete listeners[event];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlisteners[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onMIDIMessage\",\n\t\tvalue: function onMIDIMessage(message) {\n\t\t\tvar eventName = null,\n\t\t\t    data = null;\n\t\t\tswitch (message.data[0]) {\n\t\t\t\tcase 128:\n\t\t\t\t\teventName = \"NoteOff\";\n\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\tdata = NoteProcessor.processNoteEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 144:\n\t\t\t\t\tif (message.data[2] > 0) {\n\t\t\t\t\t\teventName = \"NoteOn\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\teventName = \"NoteOff\";\n\t\t\t\t\t}\n\t\t\t\t\tdata = NoteProcessor.processNoteEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 176:\n\t\t\t\t\teventName = \"Controller\";\n\t\t\t\t\tdata = NoteProcessor.processCCEvent(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 224:\n\t\t\t\t\teventName = \"PitchWheel\";\n\t\t\t\t\tdata = NoteProcessor.processPitchWheel(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 208:\n\t\t\t\t\teventName = \"Aftertouch\";\n\t\t\t\t\tdata = NoteProcessor.processMidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 192:\n\t\t\t\t\teventName = \"ProgramChange\";\n\t\t\t\t\tdata = NoteProcessor.processMidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if there is no event name, then we don't support that event yet so do nothing.\n\t\t\tif (eventName !== null) {\n\t\t\t\tEvents.executeEventHandlers(eventName, data);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"executeEventHandlers\",\n\n\n\t\t// loop through all the bound events and execute with the newly processed data.\n\t\tvalue: function executeEventHandlers(event, data) {\n\t\t\tif (listeners[event]) {\n\t\t\t\tfor (var i = listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\tif (listeners[event] !== undefined) {\n\t\t\t\t\t\tif (typeof listeners[event][i] === \"function\" && listeners[event][i]) {\n\t\t\t\t\t\t\tlisteners[event][i](data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"Event handler is not a function.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onCC\",\n\n\n\t\t// EZ binding for Control Change data, just pass in the CC number and handler. Can only be unbound with unbindALL()\n\t\tvalue: function onCC(cc, handler) {\n\t\t\tvar wrapper = function wrapper(data) {\n\t\t\t\tif (data.cc == cc) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.on(\"Controller\", wrapper);\n\t\t}\n\t}, {\n\t\tkey: \"keyToggle\",\n\n\n\t\t// EZ binding for key presses, bind these two handlers to key on/off. Can only be unbound with unbindALL()\n\t\tvalue: function keyToggle(handlerOn, handlerOff) {\n\t\t\tthis.on(\"NoteOn\", handlerOn);\n\t\t\tthis.on(\"NoteOff\", handlerOff);\n\t\t}\n\t}, {\n\t\tkey: \"onNoteNumber\",\n\n\n\t\t// currently broken. will bind an event to particular keypress.\n\t\t// this.onNoteName (name, handler) {\n\t\t//     let wrapper (data) {\n\t\t//         if(typeof data.note_name === \"string\") {\n\t\t//             if (name.length > 1) {\n\t\t//                 let dataname = new RegExp(name);\n\t\t//                 if (data.note_name.match(dataname)) {\n\t\t//                     handler(data);\n\t\t//                 }\n\t\t//             } else {\n\t\t//                 if (data.note_name === name) {\n\t\t//                     handler(data);\n\t\t//                 }\n\t\t//             }\n\t\t//         } else {\n\t\t//             data.note_name.forEach(function(notename){\n\t\t//                 if(notename === name) {\n\t\t//                     handler(data);\n\t\t//                 }\n\t\t//             })\n\t\t//         }\n\t\t//     };\n\t\t//     this.on(\"NoteOn\", wrapper);\n\t\t// };\n\t\t// EZ binding for key values. Can only be unbound with unbindALL()\n\t\tvalue: function onNoteNumber(number, handler) {\n\t\t\tvar wrapper = function wrapper(data) {\n\t\t\t\tif (data.value == number) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.on(\"NoteOn\", wrapper);\n\t\t}\n\t}, {\n\t\tkey: \"offNoteNumber\",\n\n\n\t\t// EZ binding for key values. Can only be unbound with unbindALL()\n\t\tvalue: function offNoteNumber(number, handler) {\n\t\t\tvar wrapper = function wrapper(data) {\n\t\t\t\tif (data.value == number) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.on(\"NoteOff\", wrapper);\n\t\t}\n\t}, {\n\t\tkey: \"keyToggleRange\",\n\n\n\t\t// EZ binding for a range of key values, bind these two handlers to key value. Can only be unbound with unbindALL()\n\t\tvalue: function keyToggleRange(min, max, onHandler, offHandler) {\n\t\t\tthis.onRange(min, max, onHandler);\n\t\t\tthis.offRange(min, max, offHandler);\n\t\t}\n\t}, {\n\t\tkey: \"onRange\",\n\t\tvalue: function onRange(min, max, onHandler, offHandler) {\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\tthis.onNoteNumber(i, onHandler);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i = max; _i >= min; _i--) {\n\t\t\t\t\tthis.onNoteNumber(_i, onHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"offRange\",\n\t\tvalue: function offRange(min, max, onHandler, offHandler) {\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\tthis.offNoteNumber(i, offHandler);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i2 = max; _i2 >= min; _i2--) {\n\t\t\t\t\tthis.offNoteNumber(_i2, offHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"unbindAll\",\n\n\n\t\t// Removes all bound events.\n\t\tvalue: function unbindAll() {\n\t\t\tthis.unBindKeyboard();\n\t\t\tfor (var event in listeners) {\n\t\t\t\tdelete listeners[event];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: \"bindKeyboard\",\n\t\tvalue: function bindKeyboard() {\n\t\t\twindow.addEventListener(\"keydown\", this.keyboardKeyDown);\n\t\t\twindow.addEventListener(\"keyup\", this.keyboardKeyUp);\n\t\t}\n\t}, {\n\t\tkey: \"unBindKeyboard\",\n\t\tvalue: function unBindKeyboard() {\n\t\t\twindow.removeEventListener(\"keydown\", this.keyboardKeyDown);\n\t\t\twindow.removeEventListener(\"keyup\", this.keyboardKeyUp);\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyDown\",\n\t\tvalue: function keyboardKeyDown(message) {\n\t\t\tvar newMessage = null;\n\t\t\tswitch (message.keyCode) {\n\t\t\t\tcase 90:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 60);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 83:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 61);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 88:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 62);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 68:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 63);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 67:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 64);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 86:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 65);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 71:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 66);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 66:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 67);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 72:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 68);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 78:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 69);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 74:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 70);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 77:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 71);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 188:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 72);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (newMessage !== null) {\n\t\t\t\tEvents.sendMidiMessage(newMessage);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyUp\",\n\t\tvalue: function keyboardKeyUp(message) {\n\t\t\tvar newMessage = null;\n\t\t\tswitch (message.keyCode) {\n\t\t\t\tcase 90:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 60);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 83:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 61);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 88:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 62);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 68:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 63);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 67:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 64);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 86:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 65);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 71:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 66);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 66:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 67);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 72:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 68);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 78:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 69);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 74:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 70);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 77:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 71);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 188:\n\t\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 72);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (newMessage !== null) {\n\t\t\t\tthis.sendMidiMessage(newMessage);\n\t\t\t}\n\t\t}\n\t}]);\n\treturn Events;\n}();\n\nvar key = \"C\";\nvar midiAccess = null;\n\nvar Mizzy = function () {\n    function Mizzy() {\n        classCallCheck(this, Mizzy);\n\n        if (!window.MIDIMessageEvent) {\n            window.MIDIMessageEvent = function (name, params) {\n                this.name = name;\n                return Object.assign(this, params);\n            };\n        }\n\n        this.key = key;\n        this.setKey = function (keyname) {\n            key = keyname;\n            this.key = key;\n            console.log(\"SET KEY\", key);\n        };\n        this.keysPressed = [];\n\n        // will have the midi object passed in when successfully initialized\n        this.midiAccess = null;\n\n        this.onMIDISuccess = function (midiAccessObj) {\n            // just grab from all inputs by default. It's the easiest.\n            midiAccess = midiAccessObj;\n            var inputs = midiAccess.inputs.values();\n            for (var input = inputs.next(); input && !input.done; input = inputs.next()) {\n                input.value.onmidimessage = this.onMIDIMessage.bind(this);\n            }\n        };\n        // throw an error if midi can't be initialized\n        this.onMIDIFailure = function (error) {\n            throw \"No MIDI Available\";\n        };\n        this.loopback = true;\n    }\n\n    // initialize MIZZY. Throw an alert box if the user can't use it.\n\n\n    createClass(Mizzy, [{\n        key: \"loopBackMidiMessage\",\n        value: function loopBackMidiMessage(message) {\n            this.onMIDIMessage(message);\n        }\n    }], [{\n        key: \"initialize\",\n        value: function initialize() {\n            console.log(midiAccess);\n            if (midiAccess === null) {\n                if (navigator.requestMIDIAccess) {\n                    navigator.requestMIDIAccess({\n                        sysex: false\n                    }).then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));\n                } else {\n                    alert(\"No MIDI support in your browser.\");\n                }\n            }\n        }\n    }, {\n        key: \"sendMidiMessage\",\n        value: function sendMidiMessage(message) {\n\n            if (midiAccess !== null) {\n                var outputs = midiAccess.outputs.values();\n                for (var output = outputs.next(); output && !output.done; output = outputs.next()) {\n                    output.value.send(message.data, message.timeStamp);\n                }\n            }\n            if (this.loopback) {\n                this.loopBackMidiMessage(message);\n            }\n        }\n    }, {\n        key: \"createMessage\",\n        value: function createMessage(messageType, value) {\n            var data = null;\n            switch (messageType) {\n                case \"NoteOn\":\n                    data = Generate.NoteOn(value, 127);\n                    break;\n                case \"NoteOff\":\n                    data = Generate.NoteOff(value, 127);\n                    break;\n            }\n            var newMessage = new MIDIMessageEvent(\"midimessage\", { \"data\": data }) || { \"data\": data };\n            return this.processNoteEvent(newMessage, messageType);\n        }\n    }]);\n    return Mizzy;\n}();\n\nexports.MIDIData = MIDIData;\nexports.Notation = Notation;\nexports.Generate = Generate;\nexports.NoteProcessor = NoteProcessor;\nexports.Event = Events;\nexports.Mizzy = Mizzy;\n\n}((this.Mizzy = this.Mizzy || {})));\n"],"file":"mizzy.js"}