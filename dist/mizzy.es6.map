{"version":3,"names":[],"mappings":"","sources":["mizzy.es6.js"],"sourcesContent":["const midinotes = {\r\n    \"C\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\r\n    \"D\": [2, 14, 26, 38, 50, 62, 74, 86, 98, 110, 122],\r\n    \"E\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\r\n    \"F\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\r\n    \"G\": [7, 19, 31, 43, 55, 67, 79, 91, 103, 115, 127],\r\n    \"A\": [9, 21, 33, 45, 57, 69, 81, 93, 105, 117],\r\n    \"B\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119],\r\n    \"C#\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\r\n    \"D#\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\r\n    \"E#\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\r\n    \"F#\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\r\n    \"G#\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\r\n    \"A#\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\r\n    \"B#\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\r\n    \"Db\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\r\n    \"Eb\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\r\n    \"Fb\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\r\n    \"Gb\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\r\n    \"Ab\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\r\n    \"Bb\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\r\n    \"Cb\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119]\r\n};\r\n\r\nconst noteon = 0x90;\r\nconst noteoff = 0x80;\r\nconst aftertouch = 0xA0;\r\nconst controlchange = 0xB0;\r\nconst programchange = 0xC0;\r\nconst channelpressure = 0xD0;\r\nconst pitchbend = 0xE0;\r\n\r\nclass MIDIData {\r\n\r\n    static get MidiNotes () { return midinotes; }\r\n    static get NoteOff() {return noteoff; }\r\n    static get NoteOn() {return noteon; }\r\n    static get AfterTouch() {return aftertouch;}\r\n    static get ControlChange() {return controlchange;}\r\n    static get ProgramChange() {return programchange;}\r\n    static get ChannelPressure() {return channelpressure;}\r\n    static get PitchBend() {return pitchbend;}\r\n}\n\nconst accidentals = {\r\n    \"C\"  : \"#\",\r\n    \"G\"  : \"#\",\r\n    \"D\"  : \"#\",\r\n    \"A\"  : \"#\",\r\n    \"E\"  : \"#\",\r\n    \"B\"  : \"#\",\r\n    \"Cb\" : \"b\",\r\n    \"F#\" : \"#\",\r\n    \"Gb\" : \"b\",\r\n    \"C#\" : \"#\",\r\n    \"Db\" : \"b\",\r\n    \"Ab\" : \"b\",\r\n    \"Eb\" : \"b\",\r\n    \"Bb\" : \"b\",\r\n    \"F\"  : \"b\"\r\n};\r\n\r\nconst keynotes$1 = {\r\n    \"C\":  [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"],\r\n    \"G\":  [\"G\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F#\"],\r\n    \"D\":  [\"D\", \"E\", \"F#\", \"G\", \"A\", \"B\", \"C#\"],\r\n    \"A\":  [\"A\", \"B\", \"C#\", \"D\", \"E\", \"F#\", \"G#\"],\r\n    \"E\":  [\"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D#\"],\r\n    \"B\":  [\"B\", \"C#\", \"D#\", \"E\", \"F#\", \"G#\", \"A#\"],\r\n    \"F#\": [\"F#\", \"G#\", \"A#\", \"B\", \"C#\", \"D#\", \"E#\"],\r\n    \"C#\": [\"C#\", \"D#\", \"E#\", \"F#\", \"G#\", \"A#\", \"B#\"],\r\n    \"Cb\": [\"Cb\", \"Db\", \"Eb\", \"Fb\", \"Gb\", \"Ab\", \"Bb\"],\r\n    \"Gb\": [\"Gb\", \"Ab\", \"Bb\", \"Cb\", \"Db\", \"Eb\", \"F\"],\r\n    \"Db\": [\"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\", \"Bb\", \"C\"],\r\n    \"Ab\": [\"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"G\"],\r\n    \"Eb\": [\"Eb\", \"F\", \"G\", \"Ab\", \"Bb\", \"C\", \"D\"],\r\n    \"Bb\": [\"Bb\", \"C\", \"D\", \"Eb\", \"F\", \"G\", \"A\"],\r\n    \"F\":  [\"F\", \"G\", \"A\", \"Bb\", \"C\", \"D\", \"E\"]\r\n};\r\n\r\nconst keys = [\"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"Cb\", \"F#\", \"Gb\", \"C#\", \"Db\", \"Ab\", \"Eb\",\"Bb\",\"F\"];\r\n\r\nclass Notation {\r\n    static get Keys () { return keys; }\r\n    static get KeyNotes () { return keynotes$1; }\r\n    static get Accidentals () {return accidentals; }\r\n}\n\nclass Generate {\r\n\r\n    static NoteOn (noteNumber, velocity) { new Uint8Array([MIDIData.NoteOn, noteNumber, velocity]); }\r\n    static NoteOff (noteNumber, velocity) { new Uint8Array([MIDIData.NoteOff, noteNumber, velocity]);}\r\n    static AfterTouch (noteNumber, value) {new Uint8Array([MIDIData.AfterTouch, noteNumber, value]);}\r\n    static ControlChange (controller, value) {new Uint8Array([MIDIData.ControlChange,controller, value ]);}\r\n    static ProgramChange (instrument) {new Uint8Array([MIDIData.ProgramChange, instrument]);}\r\n    static ChannelPressure (pressure) {new Uint8Array([MIDIData.ChannelPressure, pressure]);}\r\n    static PitchBend (value) {\r\n        // @todo http://stackoverflow.com/questions/30911185/javascript-reading-3-bytes-buffer-as-an-integer\r\n        var msb = 1,\r\n            lsb = 1;\r\n        new Uint8Array([MIDIData.ChannelPressure, msb, lsb]);\r\n    }\r\n}\n\nlet notes = MIDIData.MidiNotes;\r\n\r\nclass NoteProcessor {\r\n\t// add all of our extra data to the MIDI message event.\r\n\tstatic processNoteEvent(message, messageType) {\r\n\t\tconst notes = this.getNoteNames(message.data[1]);\r\n\t\tconst data = {\r\n\t\t\t\"enharmonics\": notes,\r\n\t\t\t\"note\": this.findNoteInKey(notes, this.key),\r\n\t\t\t\"inKey\": this.isNoteInKey(notes, this.key),\r\n\t\t\t\"value\": message.data[1],\r\n\t\t\t\"velocity\": message.data[2],\r\n\t\t\t\"frequency\": 440 * Math.pow(2, (message.data[1] - 69) / 12)\r\n\t\t};\r\n\t\tswitch (messageType) {\r\n\t\t\tcase \"NoteOn\":\r\n\t\t\t\tthis.keysPressed[message.data[1]] = data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"NoteOff\":\r\n\t\t\t\tdelete this.keysPressed[message.data[1]];\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\treturn Object.assign(message, data);\r\n\t};\r\n\r\n\t// add all of our extra data to the MIDI message event.\r\n\tstatic processCCEvent(message, ccNameOverride) {\r\n\t\tObject.assign(message, {\r\n\t\t\t\"cc\": ccNameOverride || message.data[1],\r\n\t\t\t\"value\": message.data[2],\r\n\t\t\t\"ratio\": message.data[2] / 127,\r\n\t\t\t\"timestamp\": message.receivedTime\r\n\t\t});\r\n\t}\r\n\r\n\t// add all of our extra data to the MIDI message event.\r\n\tstatic processMidiControlEvent(message, controlName) {\r\n\t\tObject.assign(message, {\r\n\t\t\t\"cc\": controlName,\r\n\t\t\t\"value\": message.data[1],\r\n\t\t\t\"ratio\": message.data[1] / 127,\r\n\t\t\t\"timestamp\": message.receivedTime\r\n\t\t});\r\n\t}\r\n\r\n\t// add all of our extra data to the MIDI message event.\r\n\tstatic processPitchWheel(message) {\r\n\t\tconst raw = message.data[1] | (message.data[2] << 7), calc = -(8192 - raw), ratio = calc / 8192;\r\n\t\treturn Object.assign(message, {\r\n\t\t\t\"cc\": \"pitchwheel\",\r\n\t\t\t\"value\": raw,\r\n\t\t\t\"polar\": calc,\r\n\t\t\t\"polarRatio\": ratio,\r\n\t\t\t\"timestamp\": message.receivedTime\r\n\t\t});\r\n\t}\r\n\r\n\t// process the midi message. Go through each type and add processed data\r\n\t// when done, check for any bound events and run them.\r\n\r\n\t// get a list of notes that match this noteNumber\r\n\tstatic getNoteNames(noteNumber) {\r\n\t\tlet noteNames = []; // create a list for the notes\r\n\t\tfor (var note in notes) {\r\n\t\t\t// loop through the note table and push notes that match.\r\n\t\t\tnotes[note].forEach(keynumber =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (noteNumber === keynumber) {\r\n\t\t\t\t\t\tnoteNames.push(note);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t;\r\n\t\t}\r\n\t\treturn noteNames;\r\n\t};\r\n\r\n\t// find the first note that is in the current key\r\n\tstatic findNoteInKey(notes, key) {\r\n\t\t// loop through the note list\r\n\t\tfor (let i = 0; i < notes.length; i++) {\r\n\t\t\tvar note = notes[i];\r\n\t\t\tif (this.matchNoteInKey(note, key)) {\r\n\t\t\t\treturn note;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn notes[0];\r\n\t};\r\n\r\n\t// is this note in key\r\n\tstatic isNoteInKey(notes, key) {\r\n\t\tfor (let n = 0; n < notes.length; n++) {\r\n\t\t\tconst note = notes[n];\r\n\t\t\tif (this.matchNoteInKey(note, key)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic matchNoteInKey(note, key) {\r\n\t\tfor (let i = 0; i < keynotes[key].length; i++) {\r\n\t\t\tconst keynote = keynotes[key][i];\r\n\t\t\tif (note === keynote) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// this.findAccidental = function(notes, key) {\r\n\t//     // are there any enharmonic equivalents\r\n\t//     if (notes.length > 1) {\r\n\t//         // check to see if the first note has an accidental (indicates you're on a black key);\r\n\t//         if(notes[0].length > 1) {\r\n\t//             for (var i = 0; i < notes.length; i++) {\r\n\t//                 var note = notes[i];\r\n\t//                 // does this note match the note in key\r\n\t//                 if (note[note.length - 1] === this.accidentals[key]) {\r\n\t//                     return note;\r\n\t//                 }\r\n\t//             }\r\n\t//             return notes[0];\r\n\t//         } else {\r\n\t//             return notes[0];\r\n\t//         }\r\n\t//     } else {\r\n\t//         return notes[0];\r\n\t//     }\r\n\t// };\r\n}\n\nconst listeners = {};\r\n\r\nclass Events {\r\n\t// take this event name, and run this handler when it occurs\r\n\tstatic on(event, handler) {\r\n\t\tif (listeners[event] === undefined) {\r\n\t\t\tlisteners[event] = [handler];\r\n\t\t} else {\r\n\t\t\tlisteners[event].push(handler);\r\n\t\t}\r\n\t\treturn handler;\r\n\t};\r\n\r\n\t// unbind this event and handler\r\n\tstatic off(event, handler) {\r\n\t\tif (listeners[event]) {\r\n\t\t\tfor (let i = listeners[event].length - 1; i >= 0; i--) {\r\n\t\t\t\tif (listeners[event].length === 1) {\r\n\t\t\t\t\tdelete listeners[event];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlisteners[event].splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tstatic onMIDIMessage(message) {\r\n\t\tlet eventName = null, data = null;\r\n\t\tswitch (message.data[0]) {\r\n\t\t\tcase 128:\r\n\t\t\t\teventName = \"NoteOff\";\r\n\t\t\t\tdelete this.keysPressed[message.data[1]];\r\n\t\t\t\tdata = NoteProcessor.processNoteEvent(message, eventName);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 144:\r\n\t\t\t\tif (message.data[2] > 0) {\r\n\t\t\t\t\teventName = \"NoteOn\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\teventName = \"NoteOff\";\r\n\t\t\t\t}\r\n\t\t\t\tdata = NoteProcessor.processNoteEvent(message, eventName);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 176:\r\n\t\t\t\teventName = \"Controller\";\r\n\t\t\t\tdata = NoteProcessor.processCCEvent(message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 224:\r\n\t\t\t\teventName = \"PitchWheel\";\r\n\t\t\t\tdata = NoteProcessor.processPitchWheel(message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 208:\r\n\t\t\t\teventName = \"Aftertouch\";\r\n\t\t\t\tdata = NoteProcessor.processMidiControlEvent(message, eventName);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 192:\r\n\t\t\t\teventName = \"ProgramChange\";\r\n\t\t\t\tdata = NoteProcessor.processMidiControlEvent(message, eventName);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t// if there is no event name, then we don't support that event yet so do nothing.\r\n\t\tif (eventName !== null) {\r\n\t\t\tEvents.executeEventHandlers(eventName, data);\r\n\t\t}\r\n\t};\r\n\r\n\t// loop through all the bound events and execute with the newly processed data.\r\n\tstatic executeEventHandlers(event, data) {\r\n\t\tif (listeners[event]) {\r\n\t\t\tfor (let i = listeners[event].length - 1; i >= 0; i--) {\r\n\t\t\t\tif (listeners[event] !== undefined) {\r\n\t\t\t\t\tif (typeof listeners[event][i] === \"function\" && listeners[event][i]) {\r\n\t\t\t\t\t\tlisteners[event][i](data);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow \"Event handler is not a function.\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// EZ binding for Control Change data, just pass in the CC number and handler. Can only be unbound with unbindALL()\r\n\tstatic onCC(cc, handler) {\r\n\t\tconst wrapper = data => {\r\n\t\t\tif (data.cc == cc) {\r\n\t\t\t\thandler(data);\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.on(\"Controller\", wrapper);\r\n\t};\r\n\r\n\t// EZ binding for key presses, bind these two handlers to key on/off. Can only be unbound with unbindALL()\r\n\tstatic keyToggle(handlerOn, handlerOff) {\r\n\t\tthis.on(\"NoteOn\", handlerOn);\r\n\t\tthis.on(\"NoteOff\", handlerOff);\r\n\t};\r\n\r\n\t// currently broken. will bind an event to particular keypress.\r\n\t// this.onNoteName (name, handler) {\r\n\t//     let wrapper (data) {\r\n\t//         if(typeof data.note_name === \"string\") {\r\n\t//             if (name.length > 1) {\r\n\t//                 let dataname = new RegExp(name);\r\n\t//                 if (data.note_name.match(dataname)) {\r\n\t//                     handler(data);\r\n\t//                 }\r\n\t//             } else {\r\n\t//                 if (data.note_name === name) {\r\n\t//                     handler(data);\r\n\t//                 }\r\n\t//             }\r\n\t//         } else {\r\n\t//             data.note_name.forEach(function(notename){\r\n\t//                 if(notename === name) {\r\n\t//                     handler(data);\r\n\t//                 }\r\n\t//             })\r\n\t//         }\r\n\t//     };\r\n\t//     this.on(\"NoteOn\", wrapper);\r\n\t// };\r\n\t// EZ binding for key values. Can only be unbound with unbindALL()\r\n\tstatic onNoteNumber(number, handler) {\r\n\t\tconst wrapper = data => {\r\n\t\t\tif (data.value == number) {\r\n\t\t\t\thandler(data);\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.on(\"NoteOn\", wrapper);\r\n\t};\r\n\r\n\t// EZ binding for key values. Can only be unbound with unbindALL()\r\n\tstatic offNoteNumber(number, handler) {\r\n\t\tconst wrapper = data => {\r\n\t\t\tif (data.value == number) {\r\n\t\t\t\thandler(data);\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.on(\"NoteOff\", wrapper);\r\n\t};\r\n\r\n\t// EZ binding for a range of key values, bind these two handlers to key value. Can only be unbound with unbindALL()\r\n\tstatic keyToggleRange(min, max, onHandler, offHandler) {\r\n\t\tthis.onRange(min, max, onHandler);\r\n\t\tthis.offRange(min, max, offHandler);\r\n\t};\r\n\r\n\tstatic onRange(min, max, onHandler, offHandler) {\r\n\t\tif (max > min) {\r\n\t\t\tfor (let i = min; i <= max; i++) {\r\n\t\t\t\tthis.onNoteNumber(i, onHandler);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = max; i >= min; i--) {\r\n\t\t\t\tthis.onNoteNumber(i, onHandler);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tstatic offRange(min, max, onHandler, offHandler) {\r\n\t\tif (max > min) {\r\n\t\t\tfor (let i = min; i <= max; i++) {\r\n\t\t\t\tthis.offNoteNumber(i, offHandler);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = max; i >= min; i--) {\r\n\t\t\t\tthis.offNoteNumber(i, offHandler);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Removes all bound events.\r\n\tstatic unbindAll() {\r\n\t\tthis.unBindKeyboard();\r\n\t\tfor (const event in listeners) {\r\n\t\t\tdelete listeners[event];\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tstatic bindKeyboard() {\r\n\t\twindow.addEventListener(\"keydown\", this.keyboardKeyDown);\r\n\t\twindow.addEventListener(\"keyup\", this.keyboardKeyUp);\r\n\t};\r\n\r\n\tstatic unBindKeyboard() {\r\n\t\twindow.removeEventListener(\"keydown\", this.keyboardKeyDown);\r\n\t\twindow.removeEventListener(\"keyup\", this.keyboardKeyUp);\r\n\t};\r\n\r\n\tstatic keyboardKeyDown(message) {\r\n\t\tlet newMessage = null;\r\n\t\tswitch (message.keyCode) {\r\n\t\t\tcase 90:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 60);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 83:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 61);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 88:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 62);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 68:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 63);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 67:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 64);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 86:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 65);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 71:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 66);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 66:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 67);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 72:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 68);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 78:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 69);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 74:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 70);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 77:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 71);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 188:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOn\", 72);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif (newMessage !== null) {\r\n\t\t\tEvents.sendMidiMessage(newMessage);\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tstatic keyboardKeyUp(message) {\r\n\t\tlet newMessage = null;\r\n\t\tswitch (message.keyCode) {\r\n\t\t\tcase 90:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 60);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 83:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 61);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 88:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 62);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 68:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 63);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 67:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 64);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 86:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 65);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 71:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 66);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 66:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 67);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 72:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 68);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 78:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 69);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 74:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 70);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 77:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 71);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 188:\r\n\t\t\t\tnewMessage = this.createMessage(\"NoteOff\", 72);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif (newMessage !== null) {\r\n\t\t\tthis.sendMidiMessage(newMessage);\r\n\t\t}\r\n\t}\r\n\r\n}\n\nlet key = \"C\";\r\nlet midiAccess = null;\r\n\r\n\r\nclass Mizzy {\r\n    constructor () {\r\n        if(!window.MIDIMessageEvent) {\r\n            window.MIDIMessageEvent = function (name, params) {\r\n                this.name = name;\r\n                return Object.assign(this, params);\r\n            };\r\n        }\r\n\r\n        this.key = key;\r\n        this.setKey = function(keyname) {\r\n            key = keyname;\r\n            this.key = key;\r\n            console.log(\"SET KEY\", key);\r\n        };\r\n        this.keysPressed = [];\r\n\r\n        // will have the midi object passed in when successfully initialized\r\n        this.midiAccess = null;\r\n\r\n        this.onMIDISuccess = function (midiAccessObj) {\r\n            // just grab from all inputs by default. It's the easiest.\r\n            midiAccess = midiAccessObj;\r\n            const inputs = midiAccess.inputs.values();\r\n            for (let input = inputs.next(); input && !input.done; input = inputs.next()) {\r\n                input.value.onmidimessage = this.onMIDIMessage.bind(this);\r\n            }\r\n        };\r\n        // throw an error if midi can't be initialized\r\n        this.onMIDIFailure = error => {\r\n            throw \"No MIDI Available\"\r\n        };\r\n        this.loopback = true;\r\n    }\r\n\r\n\r\n    // initialize MIZZY. Throw an alert box if the user can't use it.\r\n    static initialize () {\r\n        console.log(midiAccess);\r\n        if(midiAccess === null) {\r\n            if (navigator.requestMIDIAccess) {\r\n                navigator.requestMIDIAccess({\r\n                    sysex: false\r\n                }).then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));\r\n            } else {\r\n                alert(\"No MIDI support in your browser.\");\r\n            }\r\n        }\r\n    };\r\n\r\n    static sendMidiMessage (message) {\r\n\r\n        if(midiAccess !== null) {\r\n            const outputs = midiAccess.outputs.values();\r\n            for (let output = outputs.next(); output && !output.done; output = outputs.next()) {\r\n                output.value.send(message.data, message.timeStamp);\r\n            }\r\n        }\r\n        if(this.loopback) {\r\n            this.loopBackMidiMessage(message);\r\n        }\r\n    };\r\n    static createMessage (messageType, value) {\r\n        let data = null;\r\n        switch (messageType) {\r\n            case \"NoteOn\":\r\n                data = Generate.NoteOn(value, 127);\r\n                break;\r\n            case \"NoteOff\":\r\n                data = Generate.NoteOff(value, 127);\r\n                break;\r\n        }\r\n        const newMessage = new MIDIMessageEvent(\"midimessage\", {\"data\": data}) || {\"data\": data};\r\n        return this.processNoteEvent(newMessage, messageType);\r\n    };\r\n    loopBackMidiMessage (message) {\r\n        this.onMIDIMessage(message);\r\n    };\r\n}\n\nexport { MIDIData, Notation, Generate, NoteProcessor, Events as Event, Mizzy };\n"],"file":"mizzy.es6.js"}