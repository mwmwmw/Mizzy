{"version":3,"names":[],"mappings":"","sources":["mizzy.cjs.js"],"sourcesContent":["'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Events = function () {\n\tfunction Events() {\n\t\tclassCallCheck(this, Events);\n\n\t\tthis.listeners = {};\n\t}\n\n\t// take this event name, and run this handler when it occurs\n\n\n\tcreateClass(Events, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(event, handler) {\n\t\t\tif (this.listeners[event] === undefined) {\n\t\t\t\tthis.listeners[event] = [handler];\n\t\t\t} else {\n\t\t\t\tthis.listeners[event].push(handler);\n\t\t\t}\n\t\t\treturn handler;\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\n\n\t\t// unbind this event and handler\n\t\tvalue: function off(event) {\n\t\t\tvar handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tif (this.listeners[event]) {\n\t\t\t\tif (handler == null) {\n\t\t\t\t\tfor (var i = this.listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (this.listeners[event].length === 1) {\n\t\t\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.listeners[event].splice(i, 1);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var _i = 0; _i < this.listeners[event].length; _i++) {\n\t\t\t\t\t\tif (this.listeners[event][_i] == handler) {\n\t\t\t\t\t\t\tthis.listeners[event].splice(_i, 1);\n\t\t\t\t\t\t\tif (this.listeners[event].length === 0) {\n\t\t\t\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"trigger\",\n\t\tvalue: function trigger(event, data) {\n\t\t\tif (this.listeners[event]) {\n\t\t\t\tfor (var i = this.listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\tif (this.listeners[event] !== undefined) {\n\t\t\t\t\t\tif (typeof this.listeners[event][i] === \"function\" && this.listeners[event][i]) {\n\t\t\t\t\t\t\tthis.listeners[event][i](data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"Event handler is not a function.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\treturn Events;\n}();\n\nvar GLOBAL_TUNE = 440;\nvar MIDI_14BIT_MAX_VALUE = 16384;\nvar MIDI_MAX_VALUE = 127;\n\nvar Convert = function () {\n\tfunction Convert() {\n\t\tclassCallCheck(this, Convert);\n\t}\n\n\tcreateClass(Convert, null, [{\n\t\tkey: \"MIDINoteToFrequency\",\n\t\tvalue: function MIDINoteToFrequency(midinote) {\n\t\t\tvar tune = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GLOBAL_TUNE;\n\n\t\t\treturn tune * Math.pow(2, (midinote - 69) / 12); //\n\t\t}\n\t}, {\n\t\tkey: \"PitchWheelToPolar\",\n\t\tvalue: function PitchWheelToPolar(raw) {\n\t\t\treturn -(MIDI_14BIT_MAX_VALUE * 0.5 - raw);\n\t\t}\n\t}, {\n\t\tkey: \"PitchWheelToPolarRatio\",\n\t\tvalue: function PitchWheelToPolarRatio(raw) {\n\t\t\treturn Convert.PitchWheelToPolar(raw) / (MIDI_14BIT_MAX_VALUE * 0.5);\n\t\t}\n\t}, {\n\t\tkey: \"MidiValueToRatio\",\n\t\tvalue: function MidiValueToRatio(value) {\n\t\t\treturn value / MIDI_MAX_VALUE;\n\t\t}\n\t}, {\n\t\tkey: \"MidiValueToPolarRatio\",\n\t\tvalue: function MidiValueToPolarRatio(value) {\n\t\t\tvar halfmax = MIDI_MAX_VALUE * 0.5;\n\t\t\treturn -(halfmax - value) / halfmax;\n\t\t}\n\t}, {\n\t\tkey: \"MidiChannel\",\n\t\tvalue: function MidiChannel(value) {\n\t\t\treturn (value & 0x0F) + 1;\n\t\t}\n\t}]);\n\treturn Convert;\n}();\n\nvar MIDI_NOTE_ON = 0x90;\nvar MIDI_NOTE_OFF = 0x80;\nvar MIDI_AFTERTOUCH = 0xA0;\nvar MIDI_CONTROL_CHANGE = 0xB0;\nvar MIDI_PROGRAM_CHANGE = 0xC0;\nvar MIDI_CHANNEL_PRESSURE = 0xD0;\nvar MIDI_PITCHBEND = 0xE0;\n\nvar MIDI_MESSAGE_EVENT = \"midimessage\";\n\nvar NOTE_ON_EVENT = \"NoteOn\";\nvar NOTE_OFF_EVENT = \"NoteOff\";\nvar PITCHWHEEL_EVENT = \"PitchWheel\";\nvar CONTROLLER_EVENT = \"Controller\";\nvar PROGRAM_CHANGE_EVENT$1 = \"ProgramChange\";\nvar AFTERTOUCH_EVENT$1 = \"Aftertouch\";\n\nvar KEYBOARD_EVENT_KEY_DOWN = \"keydown\";\nvar KEYBOARD_EVENT_KEY_UP = \"keyup\";\n\nvar ENHARMONIC_KEYS = [\"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"Cb\", \"F#\", \"Gb\", \"C#\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\"];\n\nvar MIDI_NOTE_MAP = {\n\t\"C\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n\t\"D\": [2, 14, 26, 38, 50, 62, 74, 86, 98, 110, 122],\n\t\"E\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n\t\"F\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n\t\"G\": [7, 19, 31, 43, 55, 67, 79, 91, 103, 115, 127],\n\t\"A\": [9, 21, 33, 45, 57, 69, 81, 93, 105, 117],\n\t\"B\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119],\n\t\"C#\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n\t\"D#\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n\t\"E#\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n\t\"F#\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n\t\"G#\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n\t\"A#\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n\t\"B#\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n\t\"Db\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n\t\"Eb\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n\t\"Fb\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n\t\"Gb\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n\t\"Ab\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n\t\"Bb\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n\t\"Cb\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119]\n};\n\n\n\nvar KEY_NOTE_ARRAYS = {\n\t\"C\": [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"],\n\t\"G\": [\"G\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F#\"],\n\t\"D\": [\"D\", \"E\", \"F#\", \"G\", \"A\", \"B\", \"C#\"],\n\t\"A\": [\"A\", \"B\", \"C#\", \"D\", \"E\", \"F#\", \"G#\"],\n\t\"E\": [\"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D#\"],\n\t\"B\": [\"B\", \"C#\", \"D#\", \"E\", \"F#\", \"G#\", \"A#\"],\n\t\"F#\": [\"F#\", \"G#\", \"A#\", \"B\", \"C#\", \"D#\", \"E#\"],\n\t\"C#\": [\"C#\", \"D#\", \"E#\", \"F#\", \"G#\", \"A#\", \"B#\"],\n\t\"Cb\": [\"Cb\", \"Db\", \"Eb\", \"Fb\", \"Gb\", \"Ab\", \"Bb\"],\n\t\"Gb\": [\"Gb\", \"Ab\", \"Bb\", \"Cb\", \"Db\", \"Eb\", \"F\"],\n\t\"Db\": [\"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\", \"Bb\", \"C\"],\n\t\"Ab\": [\"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"G\"],\n\t\"Eb\": [\"Eb\", \"F\", \"G\", \"Ab\", \"Bb\", \"C\", \"D\"],\n\t\"Bb\": [\"Bb\", \"C\", \"D\", \"Eb\", \"F\", \"G\", \"A\"],\n\t\"F\": [\"F\", \"G\", \"A\", \"Bb\", \"C\", \"D\", \"E\"]\n};\n\nvar DataProcess = function () {\n\tfunction DataProcess() {\n\t\tclassCallCheck(this, DataProcess);\n\t}\n\n\tcreateClass(DataProcess, null, [{\n\t\tkey: \"NoteEvent\",\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function NoteEvent(message) {\n\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENHARMONIC_KEYS[0];\n\t\t\tvar transpose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t\t\tvar value = message.data[1] + transpose;\n\t\t\tvar notes = this.getNoteNames(value);\n\t\t\tvar data = {\n\t\t\t\t\"enharmonics\": notes,\n\t\t\t\t\"note\": DataProcess.findNoteInKey(notes, key),\n\t\t\t\t\"inKey\": DataProcess.isNoteInKey(notes, key),\n\t\t\t\t\"value\": value,\n\t\t\t\t\"velocity\": message.data[2],\n\t\t\t\t\"frequency\": Convert.MIDINoteToFrequency(value),\n\t\t\t\t\"channel\": Convert.MidiChannel(message.data[0])\n\t\t\t};\n\t\t\treturn Object.assign(message, data);\n\t\t}\n\t}, {\n\t\tkey: \"CCEvent\",\n\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function CCEvent(message, ccNameOverride) {\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": ccNameOverride || message.data[1],\n\t\t\t\t\"value\": message.data[2],\n\t\t\t\t\"ratio\": Convert.MidiValueToRatio(message.data[2]),\n\t\t\t\t\"polarRatio\": Convert.MidiValueToPolarRatio(message.data[2]),\n\t\t\t\t\"channel\": Convert.MidiChannel(message.data[0])\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"MidiControlEvent\",\n\t\tvalue: function MidiControlEvent(message, controlName) {\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": controlName,\n\t\t\t\t\"value\": message.data[1],\n\t\t\t\t\"ratio\": Convert.MidiValueToRatio(message.data[2]),\n\t\t\t\t\"channel\": Convert.MidiChannel(message.data[0])\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"PitchWheelEvent\",\n\t\tvalue: function PitchWheelEvent(message) {\n\t\t\tvar raw = message.data[1] | message.data[2] << 7;\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": \"pitchwheel\",\n\t\t\t\t\"value\": raw,\n\t\t\t\t\"polar\": Convert.PitchWheelToPolar(raw),\n\t\t\t\t\"polarRatio\": Convert.PitchWheelToPolarRatio(raw),\n\t\t\t\t\"channel\": Convert.MidiChannel(message.data[0])\n\t\t\t});\n\t\t}\n\n\t\t// process the midi message. Go through each type and add processed data\n\t\t// when done, check for any bound events and run them.\n\n\t\t// get a list of notes that match this noteNumber\n\n\t}, {\n\t\tkey: \"getNoteNames\",\n\t\tvalue: function getNoteNames(noteNumber) {\n\t\t\tvar noteNames = []; // create a list for the notes\n\t\t\tfor (var note in MIDI_NOTE_MAP) {\n\t\t\t\t// loop through the note table and push notes that match.\n\t\t\t\tMIDI_NOTE_MAP[note].forEach(function (keynumber) {\n\t\t\t\t\tif (noteNumber === keynumber) {\n\t\t\t\t\t\tnoteNames.push(note);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn noteNames;\n\t\t}\n\t}, {\n\t\tkey: \"findNoteInKey\",\n\n\n\t\t// find the first note that is in the current key\n\t\tvalue: function findNoteInKey(notes, key) {\n\t\t\t// loop through the note list\n\t\t\tfor (var i = 0; i < notes.length; i++) {\n\t\t\t\tvar note = notes[i];\n\t\t\t\tif (DataProcess.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn note;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn notes[0];\n\t\t}\n\t}, {\n\t\tkey: \"isNoteInKey\",\n\n\n\t\t// is this note in key\n\t\tvalue: function isNoteInKey(notes, key) {\n\t\t\tfor (var n = 0; n < notes.length; n++) {\n\t\t\t\tvar note = notes[n];\n\t\t\t\tif (this.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"matchNoteInKey\",\n\t\tvalue: function matchNoteInKey(note, key) {\n\t\t\tfor (var i = 0; i < KEY_NOTE_ARRAYS[key].length; i++) {\n\t\t\t\tvar keynote = KEY_NOTE_ARRAYS[key][i];\n\t\t\t\tif (note === keynote) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}]);\n\treturn DataProcess;\n}();\n\nvar Generate = function () {\n\tfunction Generate() {\n\t\tclassCallCheck(this, Generate);\n\t}\n\n\tcreateClass(Generate, null, [{\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(noteNumber, velocity) {\n\t\t\treturn new Uint8Array([MIDI_NOTE_ON, noteNumber, velocity]);\n\t\t}\n\t}, {\n\t\tkey: \"NoteOff\",\n\t\tvalue: function NoteOff(noteNumber, velocity) {\n\t\t\treturn new Uint8Array([MIDI_NOTE_OFF, noteNumber, velocity]);\n\t\t}\n\t}, {\n\t\tkey: \"AfterTouch\",\n\t\tvalue: function AfterTouch(noteNumber, value) {\n\t\t\treturn new Uint8Array([MIDI_AFTERTOUCH, noteNumber, value]);\n\t\t}\n\t}, {\n\t\tkey: \"CC\",\n\t\tvalue: function CC(controller, value) {\n\t\t\treturn new Uint8Array([MIDI_CONTROL_CHANGE, controller, value]);\n\t\t}\n\t}, {\n\t\tkey: \"ProgramChange\",\n\t\tvalue: function ProgramChange(instrument) {\n\t\t\treturn new Uint8Array([MIDI_PROGRAM_CHANGE, instrument]);\n\t\t}\n\t}, {\n\t\tkey: \"ChannelPressure\",\n\t\tvalue: function ChannelPressure(pressure) {\n\t\t\treturn new Uint8Array([MIDI_CHANNEL_PRESSURE, pressure]);\n\t\t}\n\t}, {\n\t\tkey: \"PitchBend\",\n\t\tvalue: function PitchBend(value) {\n\t\t\tvar msb = 0,\n\t\t\t    lsb = 0;\n\t\t\treturn new Uint8Array([MIDI_PITCHBEND, msb, lsb]);\n\t\t}\n\t}, {\n\t\tkey: \"MidiEvent\",\n\t\tvalue: function MidiEvent(data, key) {\n\t\t\tvar _window = window,\n\t\t\t    MIDIMessageEvent = _window.MIDIMessageEvent;\n\n\n\t\t\tvar message = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { data: data });\n\n\t\t\tswitch (data[0] & 0xF0) {\n\t\t\t\tcase MIDI_NOTE_ON:\n\t\t\t\t\treturn DataProcess.NoteEvent(message, key);\n\t\t\t\tcase MIDI_NOTE_OFF:\n\t\t\t\t\treturn DataProcess.NoteEvent(message, key);\n\t\t\t\tcase MIDI_CONTROL_CHANGE:\n\t\t\t\t\treturn DataProcess.CCEvent(message);\n\t\t\t\tcase MIDI_PITCHBEND:\n\t\t\t\t\treturn DataProcess.PitchWheelEvent(message);\n\t\t\t\tcase MIDI_AFTERTOUCH:\n\t\t\t\t\treturn DataProcess.MidiControlEvent(message, AFTERTOUCH_EVENT);\n\t\t\t\tcase MIDI_PROGRAM_CHANGE:\n\t\t\t\t\treturn DataProcess.MidiControlEvent(message, PROGRAM_CHANGE_EVENT);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"NoteEvent\",\n\t\tvalue: function NoteEvent(messageType, value) {\n\t\t\tvar velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 127;\n\t\t\tvar _window2 = window,\n\t\t\t    MIDIMessageEvent = _window2.MIDIMessageEvent;\n\n\t\t\tvar data = null;\n\t\t\tswitch (messageType) {\n\t\t\t\tcase NOTE_ON_EVENT:\n\t\t\t\t\tdata = Generate.NoteOn(value, velocity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NOTE_OFF_EVENT:\n\t\t\t\t\tdata = Generate.NoteOff(value, velocity);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { data: data });\n\t\t\treturn DataProcess.NoteEvent(newMessage, this.key);\n\t\t}\n\t}, {\n\t\tkey: \"CCEvent\",\n\t\tvalue: function CCEvent(cc, value) {\n\t\t\tvar _window3 = window,\n\t\t\t    MIDIMessageEvent = _window3.MIDIMessageEvent;\n\n\t\t\tvar data = Generate.CC(cc, value);\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { data: data });\n\t\t\treturn DataProcess.CCEvent(newMessage);\n\t\t}\n\t}, {\n\t\tkey: \"PitchBendEvent\",\n\t\tvalue: function PitchBendEvent(value) {\n\t\t\tvar _window4 = window,\n\t\t\t    MIDIMessageEvent = _window4.MIDIMessageEvent;\n\n\t\t\tvar data = Generate.PitchBend(value);\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { data: data });\n\t\t\treturn DataProcess.CCEvent(newMessage);\n\t\t}\n\t}]);\n\treturn Generate;\n}();\n\n/**\r\n * MIDIEvents - contains all the functionality for binding and removing MIDI events\r\n */\nvar KEY_CODE_MAP = {\n\t\"90\": 60,\n\t\"83\": 61,\n\t\"88\": 62,\n\t\"68\": 63,\n\t\"67\": 64,\n\t\"86\": 65,\n\t\"71\": 66,\n\t\"66\": 67,\n\t\"72\": 68,\n\t\"78\": 69,\n\t\"74\": 70,\n\t\"77\": 71,\n\t\"188\": 72\n};\n\nvar MIDIEvents = function (_Events) {\n\tinherits(MIDIEvents, _Events);\n\n\tfunction MIDIEvents() {\n\t\tclassCallCheck(this, MIDIEvents);\n\n\t\tvar _this = possibleConstructorReturn(this, (MIDIEvents.__proto__ || Object.getPrototypeOf(MIDIEvents)).call(this));\n\n\t\t_this.keysPressed = [];\n\t\t_this.keyboardKeyPressed = [];\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * onMIDIMessage handles all incoming midi messages, processes them and then routes them to the correct event handler.\r\n  * @param message\r\n  * @param key\r\n  */\n\n\n\tcreateClass(MIDIEvents, [{\n\t\tkey: \"onMIDIMessage\",\n\t\tvalue: function onMIDIMessage(message) {\n\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENHARMONIC_KEYS[0];\n\n\t\t\tvar eventName = null,\n\t\t\t    data = null;\n\t\t\tswitch (message.data[0] & 0xF0) {\n\t\t\t\tcase MIDI_NOTE_OFF:\n\t\t\t\t\teventName = NOTE_OFF_EVENT;\n\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\tdata = DataProcess.NoteEvent(message, key);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MIDI_NOTE_ON:\n\t\t\t\t\t// handle 0 velocity as a note off event\n\t\t\t\t\tif (message.data[2] > 0) {\n\t\t\t\t\t\teventName = NOTE_ON_EVENT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teventName = NOTE_OFF_EVENT;\n\t\t\t\t\t}\n\t\t\t\t\tdata = DataProcess.NoteEvent(message, key);\n\t\t\t\t\tif (eventName == NOTE_ON_EVENT) {\n\t\t\t\t\t\tthis.keysPressed[message.data[1]] = data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MIDI_CONTROL_CHANGE:\n\t\t\t\t\teventName = CONTROLLER_EVENT;\n\t\t\t\t\tdata = DataProcess.CCEvent(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MIDI_PITCHBEND:\n\t\t\t\t\teventName = PITCHWHEEL_EVENT;\n\t\t\t\t\tdata = DataProcess.PitchWheelEvent(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MIDI_AFTERTOUCH:\n\t\t\t\t\teventName = AFTERTOUCH_EVENT$1;\n\t\t\t\t\tdata = DataProcess.MidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MIDI_PROGRAM_CHANGE:\n\t\t\t\t\teventName = PROGRAM_CHANGE_EVENT$1;\n\t\t\t\t\tdata = DataProcess.MidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if there is no event name, then we don't support that event yet so do nothing.\n\t\t\tif (eventName !== null) {\n\t\t\t\tthis.trigger(eventName, data);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onCC\",\n\n\n\t\t/**\r\n   * EZ binding for a single Control Change data, just pass in the CC number and handler. This returns an anonymous function which you should store a reference to if you want to unbind this CC later.\r\n   * @param cc\r\n   * @param handler\r\n   * @returns {Function}\r\n   */\n\t\tvalue: function onCC(cc, handler) {\n\t\t\tvar channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\tif (channel == null) {\n\t\t\t\treturn this.on(CONTROLLER_EVENT, function (data) {\n\t\t\t\t\tif (data.cc == cc) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn this.on(CONTROLLER_EVENT, function (data) {\n\t\t\t\t\tif (data.cc == cc && data.channel == channel) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Takes the CC# and Event handler and removes the event from the listeners.\r\n   * @param handler\r\n   * @returns {Boolean}\r\n   */\n\n\t}, {\n\t\tkey: \"removeCC\",\n\t\tvalue: function removeCC(handler) {\n\t\t\treturn this.off(CONTROLLER_EVENT, handler);\n\t\t}\n\n\t\t/**\r\n   * KeyToggle will bind to all MIDI note events and execute the `keyDown` handler when the key is pressed and `keyUp` handler when the key is released. This function returns the reference to the handlers created for these events. Pass this reference into removeKeyToggle to unbind these events.\r\n   *\r\n   * ### Usage\r\n   * ```\r\n   * var m = new Mizzy();\r\n   * var toggleKeys = m.keyToggle((e) => console.log(e),(e) => console.log(e));\r\n   * // when ready to unbind\r\n   * m.removeKeyToggle(toggleKeys);\r\n   * ```\r\n   *\r\n   * @param handlerOn\r\n   * @param handlerOff\r\n   * @returns {{on: Function, off: Function}}\r\n   */\n\n\t}, {\n\t\tkey: \"keyToggle\",\n\t\tvalue: function keyToggle(keyDown, keyUp) {\n\t\t\treturn {\n\t\t\t\tkeyDown: this.on(NOTE_ON_EVENT, keyDown),\n\t\t\t\tkeyUp: this.on(NOTE_OFF_EVENT, keyUp)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"removeKeyToggle\",\n\n\n\t\t/**\r\n   * This will unbind the keyToggle. Pass in the reference created when you called `keyToggle()`\r\n   * @param toggles\r\n   */\n\t\tvalue: function removeKeyToggle(toggles) {\n\t\t\tthis.off(NOTE_ON_EVENT, toggles.keyDown);\n\t\t\tthis.off(NOTE_OFF_EVENT, toggles.keyUp);\n\t\t}\n\n\t\t/**\r\n   * EZ binding for individual key values. Pass in the note number you want to wait for (ie 60 = middle c) and the handler for it. This function will return a reference to the handler created for this note.\r\n   * @param number\r\n   * @param handler\r\n   * @returns {Function}\r\n   */\n\n\t}, {\n\t\tkey: \"pressNoteNumber\",\n\t\tvalue: function pressNoteNumber(number, handler) {\n\t\t\tvar channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\tif (channel == null) {\n\t\t\t\treturn this.on(NOTE_ON_EVENT, function (data) {\n\t\t\t\t\tif (data.value == number) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn this.on(NOTE_ON_EVENT, function (data) {\n\t\t\t\t\tif (data.value == number && data.channel == channel) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removePressNoteNumber\",\n\t\tvalue: function removePressNoteNumber(handler) {\n\t\t\treturn this.off(NOTE_ON_EVENT, handler);\n\t\t}\n\t\t// EZ binding for key values. Can only be unbound with unbindALL()\n\n\t}, {\n\t\tkey: \"releaseNoteNumber\",\n\t\tvalue: function releaseNoteNumber(number, handler) {\n\t\t\tvar channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\tif (channel == null) {\n\t\t\t\treturn this.on(NOTE_OFF_EVENT, function (data) {\n\t\t\t\t\tif (data.value == number) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn this.on(NOTE_OFF_EVENT, function (data) {\n\t\t\t\t\tif (data.value == number && data.channel == channel) {\n\t\t\t\t\t\thandler(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removeReleaseNoteNumber\",\n\t\tvalue: function removeReleaseNoteNumber(handler) {\n\t\t\treturn this.off(NOTE_OFF_EVENT, handler);\n\t\t}\n\n\t\t/**\r\n   * Bind keyboard splits. \r\n   * @param min\r\n   * @param max\r\n   * @param onHandler\r\n   * @param offHandler\r\n   * @returns {{onRange: Array, offRange: Array}}\r\n   */\n\n\t}, {\n\t\tkey: \"keyToggleRange\",\n\t\tvalue: function keyToggleRange(min, max, onHandler, offHandler) {\n\t\t\tvar channel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n\t\t\treturn {\n\t\t\t\tpress: this.onSplit(min, max, onHandler, channel),\n\t\t\t\trelease: this.offSplit(min, max, offHandler, channel)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"onSplit\",\n\t\tvalue: function onSplit(min, max, onHandler) {\n\t\t\tvar channel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t\t\tvar on = [];\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\ton.push(this.pressNoteNumber(i, onHandler, channel));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i = max; _i >= min; _i--) {\n\t\t\t\t\ton.push(this.pressNoteNumber(_i, onHandler, channel));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn on;\n\t\t}\n\t}, {\n\t\tkey: \"offSplit\",\n\t\tvalue: function offSplit(min, max, offHandler) {\n\t\t\tvar channel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t\t\tvar off = [];\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\toff.push(this.releaseNoteNumber(i, offHandler, channel));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i2 = max; _i2 >= min; _i2--) {\n\t\t\t\t\toff.push(this.releaseNoteNumber(_i2, offHandler, channel));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn off;\n\t\t}\n\t}, {\n\t\tkey: \"removeKeyToggleRange\",\n\t\tvalue: function removeKeyToggleRange(ranges) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar removeOnRanges = ranges.press.forEach(function (noteHandler) {\n\t\t\t\treturn _this2.removePressNoteNumber(noteHandler);\n\t\t\t});\n\t\t\tvar removeOffRanges = ranges.release.forEach(function (noteHandler) {\n\t\t\t\treturn _this2.removeReleaseNoteNumber(noteHandler);\n\t\t\t});\n\t\t\treturn removeOffRanges == true && removeOnRanges == true;\n\t\t}\n\n\t\t/**\r\n   * Removes all bound handlers for all events. Great for when you know you need to lose all the events.\r\n   * @returns {boolean}\r\n   */\n\n\t}, {\n\t\tkey: \"unbindAll\",\n\t\tvalue: function unbindAll() {\n\t\t\tthis.unBindKeyboard();\n\t\t\tfor (var event in this.listeners) {\n\t\t\t\tdelete this.listeners[event];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: \"bindKeyboard\",\n\n\n\t\t/**\r\n   * Bind the computer (qwerty) keyboard to allow it to generate MIDI note on and note off messages.\r\n   */\n\t\tvalue: function bindKeyboard() {\n\t\t\tvar _this3 = this;\n\n\t\t\tvar channel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n\t\t\twindow.addEventListener(KEYBOARD_EVENT_KEY_DOWN, function (e) {\n\t\t\t\treturn _this3.keyboardKeyDown(e, channel);\n\t\t\t});\n\t\t\twindow.addEventListener(KEYBOARD_EVENT_KEY_UP, function (e) {\n\t\t\t\treturn _this3.keyboardKeyUp(e, channel);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"unBindKeyboard\",\n\t\tvalue: function unBindKeyboard() {\n\t\t\tvar _this4 = this;\n\n\t\t\tvar channel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n\t\t\twindow.removeEventListener(KEYBOARD_EVENT_KEY_DOWN, function (e) {\n\t\t\t\treturn _this4.keyboardKeyDown(e, channel);\n\t\t\t});\n\t\t\twindow.removeEventListener(KEYBOARD_EVENT_KEY_UP, function (e) {\n\t\t\t\treturn _this4.keyboardKeyUp(e, channel);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyDown\",\n\t\tvalue: function keyboardKeyDown(message) {\n\t\t\tvar channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tif (KEY_CODE_MAP[message.keyCode] != undefined) {\n\t\t\t\tif (this.keyboardKeyPressed[message.keyCode] != true) {\n\t\t\t\t\tthis.keyboardKeyPressed[message.keyCode] = true;\n\t\t\t\t\tvar newMessage = Generate.NoteEvent(NOTE_ON_EVENT, KEY_CODE_MAP[message.keyCode]);\n\t\t\t\t\tif (newMessage !== null) {\n\t\t\t\t\t\tthis.sendMidiMessage(newMessage, channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyUp\",\n\t\tvalue: function keyboardKeyUp(message) {\n\t\t\tvar channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tif (KEY_CODE_MAP[message.keyCode] != undefined) {\n\t\t\t\tif (this.keyboardKeyPressed[message.keyCode] == true) {\n\t\t\t\t\tdelete this.keyboardKeyPressed[message.keyCode];\n\t\t\t\t\tvar newMessage = Generate.NoteEvent(NOTE_OFF_EVENT, KEY_CODE_MAP[message.keyCode]);\n\t\t\t\t\tif (newMessage !== null) {\n\t\t\t\t\t\tthis.sendMidiMessage(newMessage, channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"sendMidiMessage\",\n\t\tvalue: function sendMidiMessage(message) {\n\t\t\tvar channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tif (channel != null) {\n\t\t\t\tmessage.data[0] = message.data[0] | parseInt(channel - 1, 16);\n\t\t\t}\n\t\t\tthis.boundOutputs.forEach(function (output) {\n\t\t\t\toutput.send(message.data, message.timeStamp);\n\t\t\t});\n\t\t\tif (this.loopback) {\n\t\t\t\tthis.onMIDIMessage(message, this.key);\n\t\t\t}\n\t\t}\n\t}]);\n\treturn MIDIEvents;\n}(Events);\n\nvar TICK_INCREMENT = 0.25;\nvar DEFAULT_LOOP_LENGTH = 16;\nvar DEFAULT_TEMPO = 120;\nvar TICK_LENGTH = 0.2;\n\nvar Clock = function (_Events) {\n\tinherits(Clock, _Events);\n\n\tfunction Clock(context) {\n\t\tclassCallCheck(this, Clock);\n\n\t\tvar _this = possibleConstructorReturn(this, (Clock.__proto__ || Object.getPrototypeOf(Clock)).call(this));\n\n\t\t_this.context = context || new AudioContext();\n\n\t\t_this.BPM = DEFAULT_TEMPO;\n\t\t_this.tickSchedule;\n\t\t_this.tick = 0;\n\t\t_this.playing = false;\n\t\t_this.loopIndex = 0;\n\t\t_this.startClock = 0;\n\t\t_this.index = 0;\n\t\t_this.looplength = DEFAULT_LOOP_LENGTH;\n\t\t_this.direction = 1;\n\t\t_this.lastTick = 0;\n\t\treturn _this;\n\t}\n\n\tcreateClass(Clock, [{\n\t\tkey: \"reset\",\n\t\tvalue: function reset() {\n\t\t\tthis.index = 0;\n\t\t\tthis.loopIndex = 0;\n\t\t}\n\t}, {\n\t\tkey: \"play\",\n\t\tvalue: function play() {\n\t\t\tvar index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t\tthis.tick = 0;\n\t\t\tthis.startClock = this.context.currentTime + 0.005;\n\t\t\tthis.index = index;\n\t\t\tthis.loopIndex = loopIndex;\n\t\t\tthis.playing = true;\n\t\t\tthis.trigger(\"play\", this.context.currentTime + 0.005);\n\t\t\tthis.schedule();\n\t\t}\n\t}, {\n\t\tkey: \"stop\",\n\t\tvalue: function stop() {\n\t\t\tthis.trigger(\"stop\");\n\t\t\tthis.playing = false;\n\t\t}\n\t}, {\n\t\tkey: \"schedule\",\n\t\tvalue: function schedule() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (this.playing) {\n\t\t\t\tvar playHead = this.context.currentTime - this.startClock;\n\t\t\t\twhile (this.tick < playHead + TICK_LENGTH) {\n\t\t\t\t\tvar localPlayHead = this.tick + this.startClock;\n\t\t\t\t\tthis.process(this.index, this.loopIndex, this.tick, playHead);\n\t\t\t\t\tthis.next();\n\t\t\t\t}\n\t\t\t\tthis.tickSchedule = setTimeout(function () {\n\t\t\t\t\treturn _this2.schedule();\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"process\",\n\t\tvalue: function process(index, loopIndex, localTime, globalTime) {\n\t\t\tvar tick = {\n\t\t\t\tindex: index, loopIndex: loopIndex, globalTime: globalTime\n\t\t\t};\n\t\t\tthis.trigger(\"tick\", tick);\n\t\t}\n\t}, {\n\t\tkey: \"next\",\n\t\tvalue: function next() {\n\t\t\tvar beat = 60 / this.BPM;\n\t\t\tthis.index++;\n\t\t\tthis.loopIndex += this.direction;\n\n\t\t\tif (this.loopIndex > this.looplength - 1) {\n\t\t\t\tthis.loopIndex = 0;\n\t\t\t} else if (this.loopIndex < 0) {\n\t\t\t\tthis.loopIndex = this.looplength - 1;\n\t\t\t}\n\n\t\t\tthis.tick += TICK_INCREMENT * beat;\n\t\t}\n\t}]);\n\treturn Clock;\n}(Events);\n\nif (window.MIDIMessageEvent === undefined) {\n\twindow.MIDIMessageEvent = MessageEvent;\n}\n\nvar Mizzy = function (_MIDIEvents) {\n\tinherits(Mizzy, _MIDIEvents);\n\tcreateClass(Mizzy, null, [{\n\t\tkey: \"Generate\",\n\t\tget: function get$$1() {\n\t\t\treturn Generate;\n\t\t}\n\t}, {\n\t\tkey: \"Clock\",\n\t\tget: function get$$1() {\n\t\t\treturn Clock;\n\t\t}\n\t}, {\n\t\tkey: \"NOTE_ON\",\n\t\tget: function get$$1() {\n\t\t\treturn NOTE_ON_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"NOTE_OFF\",\n\t\tget: function get$$1() {\n\t\t\treturn NOTE_OFF_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"CONTROLCHANGE\",\n\t\tget: function get$$1() {\n\t\t\treturn CONTROLLER_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"PITCHWHEEL\",\n\t\tget: function get$$1() {\n\t\t\treturn PITCHWHEEL_EVENT;\n\t\t}\n\t}]);\n\n\tfunction Mizzy() {\n\t\tclassCallCheck(this, Mizzy);\n\n\t\tvar _this = possibleConstructorReturn(this, (Mizzy.__proto__ || Object.getPrototypeOf(Mizzy)).call(this));\n\n\t\t_this.keysPressed = [];\n\t\t_this.midiAccess = null;\n\t\t_this.loopback = true;\n\n\t\t_this.boundInputs = [];\n\t\t_this.boundOutputs = [];\n\n\t\t_this.clock = new Clock();\n\n\t\t_this.key = ENHARMONIC_KEYS[0]; // C-Major\n\n\t\treturn _this;\n\t}\n\n\tcreateClass(Mizzy, [{\n\t\tkey: \"initialize\",\n\t\tvalue: function initialize() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (this.midiAccess === null) {\n\t\t\t\tif (navigator.requestMIDIAccess) {\n\t\t\t\t\treturn navigator.requestMIDIAccess({\n\t\t\t\t\t\tsysex: false\n\t\t\t\t\t}).then(function (e) {\n\t\t\t\t\t\treturn _this2.onMIDISuccess(e);\n\t\t\t\t\t}, function (e) {\n\t\t\t\t\t\treturn _this2.onMIDIFailure(e);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"[Mizzy] Your browser does not support Web MIDI API. You can still use the local loopback however.\");\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setKey\",\n\t\tvalue: function setKey() {\n\t\t\tvar keyletter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"C\";\n\n\t\t\tthis.key = ENHARMONIC_KEYS[ENHARMONIC_KEYS.indexOf(keyletter.toUpperCase())] || \"C\";\n\t\t}\n\t}, {\n\t\tkey: \"getMidiInputs\",\n\t\tvalue: function getMidiInputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\treturn this.midiAccess.inputs.values();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getMidiOutputs\",\n\t\tvalue: function getMidiOutputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\treturn this.midiAccess.outputs.values();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"bindToInput\",\n\t\tvalue: function bindToInput(input) {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.boundInputs.push(input);\n\t\t\tinput.onmidimessage = function (e) {\n\t\t\t\treturn _this3.onMIDIMessage(e, _this3.key);\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"unbindInput\",\n\t\tvalue: function unbindInput(input) {\n\t\t\tvar index = this.boundInputs.indexOf(input);\n\t\t\tthis.boundInputs.slice(1, index);\n\t\t\tinput.onmidimessage = null;\n\t\t}\n\t}, {\n\t\tkey: \"bindToAllInputs\",\n\t\tvalue: function bindToAllInputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\tvar inputs = this.getMidiInputs();\n\t\t\t\tfor (var input = inputs.next(); input && !input.done; input = inputs.next()) {\n\t\t\t\t\tthis.bindToInput(input.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"unbindAllInputs\",\n\t\tvalue: function unbindAllInputs() {\n\t\t\tthis.boundInputs.forEach(this.unbindInput);\n\t\t}\n\t}, {\n\t\tkey: \"bindToOutput\",\n\t\tvalue: function bindToOutput(output) {\n\t\t\tthis.boundOutputs.push(output);\n\t\t}\n\t}, {\n\t\tkey: \"bindToAllOutputs\",\n\t\tvalue: function bindToAllOutputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\tvar outputs = this.getMidiOutputs();\n\t\t\t\tfor (var output = outputs.next(); output && !output.done; output = outputs.next()) {\n\t\t\t\t\tthis.bindToOutput(output.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onMIDIFailure\",\n\t\tvalue: function onMIDIFailure(error) {\n\t\t\tthrow error;\n\t\t}\n\t}, {\n\t\tkey: \"onMIDISuccess\",\n\t\tvalue: function onMIDISuccess(midiAccessObj) {\n\t\t\tthis.midiAccess = midiAccessObj;\n\t\t}\n\t}, {\n\t\tkey: \"panic\",\n\t\tvalue: function panic() {\n\t\t\tfor (var i = 0; i < 127; i++) {\n\t\t\t\tthis.sendMidiMessage(Generate.MidiEvent(Mizzy.Generate.NoteOff(i, 127), this.key));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"keys\",\n\t\tget: function get$$1() {\n\t\t\treturn ENHARMONIC_KEYS;\n\t\t}\n\t}, {\n\t\tkey: \"outputDevices\",\n\t\tget: function get$$1() {\n\t\t\tvar deviceArray = [];\n\t\t\tvar devices = this.getMidiOutputs();\n\t\t\tfor (var input = devices.next(); input && !input.done; input = devices.next()) {\n\t\t\t\tdeviceArray.push(input.value);\n\t\t\t}\n\t\t\treturn deviceArray;\n\t\t}\n\t}, {\n\t\tkey: \"inputDevices\",\n\t\tget: function get$$1() {\n\t\t\tvar deviceArray = [];\n\t\t\tvar devices = this.getMidiInputs();\n\t\t\tfor (var input = devices.next(); input && !input.done; input = devices.next()) {\n\t\t\t\tdeviceArray.push(input.value);\n\t\t\t}\n\t\t\treturn deviceArray;\n\t\t}\n\t}]);\n\treturn Mizzy;\n}(MIDIEvents);\n\nmodule.exports = Mizzy;\n"],"file":"mizzy.cjs.js"}