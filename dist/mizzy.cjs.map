{"version":3,"names":[],"mappings":"","sources":["mizzy.cjs.js"],"sourcesContent":["'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Events = function () {\n\tfunction Events() {\n\t\tclassCallCheck(this, Events);\n\n\t\tthis.listeners = {};\n\t}\n\n\t// take this event name, and run this handler when it occurs\n\n\n\tcreateClass(Events, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(event, handler) {\n\t\t\tif (this.listeners[event] === undefined) {\n\t\t\t\tthis.listeners[event] = [handler];\n\t\t\t} else {\n\t\t\t\tthis.listeners[event].push(handler);\n\t\t\t}\n\t\t\treturn handler;\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\n\n\t\t// unbind this event and handler\n\t\tvalue: function off(event) {\n\t\t\tvar handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tif (this.listeners[event]) {\n\n\t\t\t\tfor (var i = this.listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\tif (this.listeners[event].length === 1) {\n\t\t\t\t\t\tif (handler == null) {\n\t\t\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (this.listeners[event] == handler) {\n\t\t\t\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.listeners[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\treturn Events;\n}();\n\nvar GLOBAL_TUNE = 440;\nvar MIDI_14BIT_MAX_VALUE = 16384;\nvar MIDI_MAX_VALUE = 127;\n\nvar Convert = function () {\n\tfunction Convert() {\n\t\tclassCallCheck(this, Convert);\n\t}\n\n\tcreateClass(Convert, null, [{\n\t\tkey: \"MIDINoteToFrequency\",\n\t\tvalue: function MIDINoteToFrequency(midinote) {\n\t\t\tvar tune = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GLOBAL_TUNE;\n\n\t\t\treturn tune * Math.pow(2, (midinote - 69) / 12); //\n\t\t}\n\t}, {\n\t\tkey: \"PitchWheelToPolar\",\n\t\tvalue: function PitchWheelToPolar(raw) {\n\t\t\treturn -(MIDI_14BIT_MAX_VALUE * 0.5 - raw);\n\t\t}\n\t}, {\n\t\tkey: \"PitchWheelToPolarRatio\",\n\t\tvalue: function PitchWheelToPolarRatio(raw) {\n\t\t\treturn Convert.PitchWheelToPolar(raw) / (MIDI_14BIT_MAX_VALUE * 0.5);\n\t\t}\n\t}, {\n\t\tkey: \"MidiValueToRatio\",\n\t\tvalue: function MidiValueToRatio(value) {\n\t\t\treturn value / MIDI_MAX_VALUE;\n\t\t}\n\t}, {\n\t\tkey: \"MidiValueToPolarRatio\",\n\t\tvalue: function MidiValueToPolarRatio(value) {\n\t\t\tvar halfmax = MIDI_MAX_VALUE * 0.5;\n\t\t\treturn -(halfmax - value) / halfmax;\n\t\t}\n\t}]);\n\treturn Convert;\n}();\n\nvar MIDI_NOTE_ON = 0x90;\nvar MIDI_NOTE_OFF = 0x80;\nvar MIDI_AFTERTOUCH = 0xA0;\nvar MIDI_CONTROL_CHANGE = 0xB0;\nvar MIDI_PROGRAM_CHANGE = 0xC0;\nvar MIDI_CHANNEL_PRESSURE = 0xD0;\nvar MIDI_PITCHBEND = 0xE0;\n\nvar MIDI_MESSAGE_EVENT = \"midimessage\";\n\nvar NOTE_ON_EVENT = \"NoteOn\";\nvar NOTE_OFF_EVENT = \"NoteOff\";\nvar PITCHWHEEL_EVENT = \"PitchWheel\";\nvar CONTROLLER_EVENT = \"Controller\";\nvar PROGRAM_CHANGE_EVENT = \"ProgramChange\";\nvar AFTERTOUCH_EVENT = \"Aftertouch\";\n\nvar KEYBOARD_EVENT_KEY_DOWN = \"keydown\";\nvar KEYBOARD_EVENT_KEY_UP = \"keyup\";\n\nvar ENHARMONIC_KEYS = [\"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"Cb\", \"F#\", \"Gb\", \"C#\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\"];\n\nvar MIDI_NOTE_MAP = {\n\t\"C\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n\t\"D\": [2, 14, 26, 38, 50, 62, 74, 86, 98, 110, 122],\n\t\"E\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n\t\"F\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n\t\"G\": [7, 19, 31, 43, 55, 67, 79, 91, 103, 115, 127],\n\t\"A\": [9, 21, 33, 45, 57, 69, 81, 93, 105, 117],\n\t\"B\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119],\n\t\"C#\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n\t\"D#\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n\t\"E#\": [5, 17, 29, 41, 53, 65, 77, 89, 101, 113, 125],\n\t\"F#\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n\t\"G#\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n\t\"A#\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n\t\"B#\": [0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120],\n\t\"Db\": [1, 13, 25, 37, 49, 61, 73, 85, 97, 109, 121],\n\t\"Eb\": [3, 15, 27, 39, 51, 63, 75, 87, 99, 111, 123],\n\t\"Fb\": [4, 16, 28, 40, 52, 64, 76, 88, 100, 112, 124],\n\t\"Gb\": [6, 18, 30, 42, 54, 66, 78, 90, 102, 114, 126],\n\t\"Ab\": [8, 20, 32, 44, 56, 68, 80, 92, 104, 116],\n\t\"Bb\": [10, 22, 34, 46, 58, 70, 82, 94, 106, 118],\n\t\"Cb\": [11, 23, 35, 47, 59, 71, 83, 95, 107, 119]\n};\n\n\n\nvar KEY_NOTE_ARRAYS = {\n\t\"C\": [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"],\n\t\"G\": [\"G\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F#\"],\n\t\"D\": [\"D\", \"E\", \"F#\", \"G\", \"A\", \"B\", \"C#\"],\n\t\"A\": [\"A\", \"B\", \"C#\", \"D\", \"E\", \"F#\", \"G#\"],\n\t\"E\": [\"E\", \"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D#\"],\n\t\"B\": [\"B\", \"C#\", \"D#\", \"E\", \"F#\", \"G#\", \"A#\"],\n\t\"F#\": [\"F#\", \"G#\", \"A#\", \"B\", \"C#\", \"D#\", \"E#\"],\n\t\"C#\": [\"C#\", \"D#\", \"E#\", \"F#\", \"G#\", \"A#\", \"B#\"],\n\t\"Cb\": [\"Cb\", \"Db\", \"Eb\", \"Fb\", \"Gb\", \"Ab\", \"Bb\"],\n\t\"Gb\": [\"Gb\", \"Ab\", \"Bb\", \"Cb\", \"Db\", \"Eb\", \"F\"],\n\t\"Db\": [\"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\", \"Bb\", \"C\"],\n\t\"Ab\": [\"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"G\"],\n\t\"Eb\": [\"Eb\", \"F\", \"G\", \"Ab\", \"Bb\", \"C\", \"D\"],\n\t\"Bb\": [\"Bb\", \"C\", \"D\", \"Eb\", \"F\", \"G\", \"A\"],\n\t\"F\": [\"F\", \"G\", \"A\", \"Bb\", \"C\", \"D\", \"E\"]\n};\n\nvar DataProcess = function () {\n\tfunction DataProcess() {\n\t\tclassCallCheck(this, DataProcess);\n\t}\n\n\tcreateClass(DataProcess, null, [{\n\t\tkey: \"NoteEvent\",\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function NoteEvent(message) {\n\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENHARMONIC_KEYS[0];\n\t\t\tvar transpose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t\t\tvar value = message.data[1] + transpose;\n\t\t\tvar notes = this.getNoteNames(value);\n\t\t\tvar data = {\n\t\t\t\t\"enharmonics\": notes,\n\t\t\t\t\"note\": DataProcess.findNoteInKey(notes, key),\n\t\t\t\t\"inKey\": DataProcess.isNoteInKey(notes, key),\n\t\t\t\t\"value\": value,\n\t\t\t\t\"velocity\": message.data[2],\n\t\t\t\t\"frequency\": Convert.MIDINoteToFrequency(value)\n\t\t\t};\n\t\t\treturn Object.assign(message, data);\n\t\t}\n\t}, {\n\t\tkey: \"CCEvent\",\n\n\n\t\t// add all of our extra data to the MIDI message event.\n\t\tvalue: function CCEvent(message, ccNameOverride) {\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": ccNameOverride || message.data[1],\n\t\t\t\t\"value\": message.data[2],\n\t\t\t\t\"ratio\": Convert.MidiValueToRatio(message.data[2]),\n\t\t\t\t\"polarRatio\": Convert.MidiValueToPolarRatio(message.data[2])\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"MidiControlEvent\",\n\t\tvalue: function MidiControlEvent(message, controlName) {\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": controlName,\n\t\t\t\t\"value\": message.data[1],\n\t\t\t\t\"ratio\": Convert.MidiValueToRatio(message.data[2])\n\t\t\t});\n\t\t}\n\n\t\t// add all of our extra data to the MIDI message event.\n\n\t}, {\n\t\tkey: \"PitchWheelEvent\",\n\t\tvalue: function PitchWheelEvent(message) {\n\t\t\tvar raw = message.data[1] | message.data[2] << 7;\n\t\t\treturn Object.assign(message, {\n\t\t\t\t\"cc\": \"pitchwheel\",\n\t\t\t\t\"value\": raw,\n\t\t\t\t\"polar\": Convert.PitchWheelToPolar(raw),\n\t\t\t\t\"polarRatio\": Convert.PitchWheelToPolarRatio(raw)\n\t\t\t});\n\t\t}\n\n\t\t// process the midi message. Go through each type and add processed data\n\t\t// when done, check for any bound events and run them.\n\n\t\t// get a list of notes that match this noteNumber\n\n\t}, {\n\t\tkey: \"getNoteNames\",\n\t\tvalue: function getNoteNames(noteNumber) {\n\t\t\tvar noteNames = []; // create a list for the notes\n\t\t\tfor (var note in MIDI_NOTE_MAP) {\n\t\t\t\t// loop through the note table and push notes that match.\n\t\t\t\tMIDI_NOTE_MAP[note].forEach(function (keynumber) {\n\t\t\t\t\tif (noteNumber === keynumber) {\n\t\t\t\t\t\tnoteNames.push(note);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn noteNames;\n\t\t}\n\t}, {\n\t\tkey: \"findNoteInKey\",\n\n\n\t\t// find the first note that is in the current key\n\t\tvalue: function findNoteInKey(notes, key) {\n\t\t\t// loop through the note list\n\t\t\tfor (var i = 0; i < notes.length; i++) {\n\t\t\t\tvar note = notes[i];\n\t\t\t\tif (DataProcess.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn note;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn notes[0];\n\t\t}\n\t}, {\n\t\tkey: \"isNoteInKey\",\n\n\n\t\t// is this note in key\n\t\tvalue: function isNoteInKey(notes, key) {\n\t\t\tfor (var n = 0; n < notes.length; n++) {\n\t\t\t\tvar note = notes[n];\n\t\t\t\tif (this.matchNoteInKey(note, key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"matchNoteInKey\",\n\t\tvalue: function matchNoteInKey(note, key) {\n\t\t\tfor (var i = 0; i < KEY_NOTE_ARRAYS[key].length; i++) {\n\t\t\t\tvar keynote = KEY_NOTE_ARRAYS[key][i];\n\t\t\t\tif (note === keynote) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}]);\n\treturn DataProcess;\n}();\n\nvar Generate = function () {\n\tfunction Generate() {\n\t\tclassCallCheck(this, Generate);\n\t}\n\n\tcreateClass(Generate, null, [{\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(noteNumber, velocity) {\n\t\t\treturn new Uint8Array([MIDI_NOTE_ON, noteNumber, velocity]);\n\t\t}\n\t}, {\n\t\tkey: \"NoteOff\",\n\t\tvalue: function NoteOff(noteNumber, velocity) {\n\t\t\treturn new Uint8Array([MIDI_NOTE_OFF, noteNumber, velocity]);\n\t\t}\n\t}, {\n\t\tkey: \"AfterTouch\",\n\t\tvalue: function AfterTouch(noteNumber, value) {\n\t\t\treturn new Uint8Array([MIDI_AFTERTOUCH, noteNumber, value]);\n\t\t}\n\t}, {\n\t\tkey: \"CC\",\n\t\tvalue: function CC(controller, value) {\n\t\t\treturn new Uint8Array([MIDI_CONTROL_CHANGE, controller, value]);\n\t\t}\n\t}, {\n\t\tkey: \"ProgramChange\",\n\t\tvalue: function ProgramChange(instrument) {\n\t\t\treturn new Uint8Array([MIDI_PROGRAM_CHANGE, instrument]);\n\t\t}\n\t}, {\n\t\tkey: \"ChannelPressure\",\n\t\tvalue: function ChannelPressure(pressure) {\n\t\t\treturn new Uint8Array([MIDI_CHANNEL_PRESSURE, pressure]);\n\t\t}\n\t}, {\n\t\tkey: \"PitchBend\",\n\t\tvalue: function PitchBend(value) {\n\t\t\t// @todo http://stackoverflow.com/questions/30911185/javascript-reading-3-bytes-buffer-as-an-integer\n\t\t\tvar msb = parseInt(value, 2),\n\t\t\t    lsb = parseInt(value, 2);\n\t\t\tconsole.log(msb, lsb);\n\t\t\treturn new Uint8Array([MIDI_PITCHBEND, msb, lsb]);\n\t\t}\n\t}, {\n\t\tkey: \"NoteEvent\",\n\t\tvalue: function NoteEvent(messageType, value) {\n\t\t\tvar velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 127;\n\n\t\t\tvar data = null;\n\t\t\tswitch (messageType) {\n\t\t\t\tcase NOTE_ON_EVENT:\n\t\t\t\t\tdata = Generate.NoteOn(value, velocity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NOTE_OFF_EVENT:\n\t\t\t\t\tdata = Generate.NoteOff(value, velocity);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { \"data\": data }) || { \"data\": data };\n\t\t\treturn DataProcess.NoteEvent(newMessage, this.key);\n\t\t}\n\t}, {\n\t\tkey: \"CCEvent\",\n\t\tvalue: function CCEvent(cc, value) {\n\t\t\tvar data = Generate.CC(cc, value);\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { \"data\": data });\n\t\t\treturn DataProcess.CCEvent(newMessage);\n\t\t}\n\t}, {\n\t\tkey: \"PitchBendEvent\",\n\t\tvalue: function PitchBendEvent(value) {\n\t\t\tvar data = Generate.PitchBend(value);\n\t\t\tvar newMessage = new MIDIMessageEvent(MIDI_MESSAGE_EVENT, { \"data\": data });\n\t\t\treturn DataProcess.CCEvent(newMessage);\n\t\t}\n\t}]);\n\treturn Generate;\n}();\n\nvar KEY_CODE_MAP = {\n\t\"90\": 60,\n\t\"83\": 61,\n\t\"88\": 62,\n\t\"68\": 63,\n\t\"67\": 64,\n\t\"86\": 65,\n\t\"71\": 66,\n\t\"66\": 67,\n\t\"72\": 68,\n\t\"78\": 69,\n\t\"74\": 70,\n\t\"77\": 71,\n\t\"188\": 72\n};\n\nvar MIDIEvents = function (_Events) {\n\tinherits(MIDIEvents, _Events);\n\n\tfunction MIDIEvents() {\n\t\tclassCallCheck(this, MIDIEvents);\n\n\t\tvar _this = possibleConstructorReturn(this, (MIDIEvents.__proto__ || Object.getPrototypeOf(MIDIEvents)).call(this));\n\n\t\t_this.keysPressed = [];\n\t\t_this.keyboadKeyPressed = [];\n\t\treturn _this;\n\t}\n\n\tcreateClass(MIDIEvents, [{\n\t\tkey: \"onMIDIMessage\",\n\t\tvalue: function onMIDIMessage(message) {\n\t\t\tvar key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENHARMONIC_KEYS[0];\n\n\t\t\tvar eventName = null,\n\t\t\t    data = null;\n\t\t\tswitch (message.data[0]) {\n\t\t\t\tcase 128:\n\t\t\t\t\teventName = NOTE_OFF_EVENT;\n\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\tdata = DataProcess.NoteEvent(message, key);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 144:\n\t\t\t\t\t// handle 0 velocity as a note off event\n\t\t\t\t\tif (message.data[2] > 0) {\n\t\t\t\t\t\teventName = NOTE_ON_EVENT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teventName = NOTE_OFF_EVENT;\n\t\t\t\t\t}\n\t\t\t\t\tdata = DataProcess.NoteEvent(message, key);\n\t\t\t\t\tif (eventName == NOTE_ON_EVENT) {\n\t\t\t\t\t\tthis.keysPressed[message.data[1]] = data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.keysPressed[message.data[1]];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 176:\n\t\t\t\t\teventName = CONTROLLER_EVENT;\n\t\t\t\t\tdata = DataProcess.CCEvent(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 224:\n\t\t\t\t\teventName = PITCHWHEEL_EVENT;\n\t\t\t\t\tdata = DataProcess.PitchWheelEvent(message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 208:\n\t\t\t\t\teventName = AFTERTOUCH_EVENT;\n\t\t\t\t\tdata = DataProcess.MidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 192:\n\t\t\t\t\teventName = PROGRAM_CHANGE_EVENT;\n\t\t\t\t\tdata = DataProcess.MidiControlEvent(message, eventName);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if there is no event name, then we don't support that event yet so do nothing.\n\t\t\tif (eventName !== null) {\n\t\t\t\tthis.executeEventHandlers(eventName, data);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"executeEventHandlers\",\n\n\n\t\t// loop through all the bound events and execute with the newly processed data.\n\t\tvalue: function executeEventHandlers(event, data) {\n\t\t\tif (this.listeners[event]) {\n\t\t\t\tfor (var i = this.listeners[event].length - 1; i >= 0; i--) {\n\t\t\t\t\tif (this.listeners[event] !== undefined) {\n\t\t\t\t\t\tif (typeof this.listeners[event][i] === \"function\" && this.listeners[event][i]) {\n\t\t\t\t\t\t\tthis.listeners[event][i](data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"Event handler is not a function.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onCC\",\n\n\n\t\t// EZ binding for Control Change data, just pass in the CC number and handler. Can only be unbound with unbindALL()\n\t\tvalue: function onCC(cc, handler) {\n\t\t\treturn this.on(CONTROLLER_EVENT, function (data) {\n\t\t\t\tif (data.cc == cc) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"keyToggle\",\n\n\n\t\t// EZ binding for key presses, bind these two handlers to key on/off. Can only be unbound with unbindALL()\n\t\tvalue: function keyToggle(handlerOn, handlerOff) {\n\t\t\treturn {\n\t\t\t\ton: this.on(NOTE_ON_EVENT, handlerOn),\n\t\t\t\toff: this.on(NOTE_OFF_EVENT, handlerOff)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"removeKeyToggle\",\n\t\tvalue: function removeKeyToggle(toggles) {\n\t\t\tthis.off(NOTE_ON_EVENT, toggles.on);\n\t\t\tthis.off(NOTE_OFF_EVENT, toggles.off);\n\t\t}\n\n\t\t// EZ binding for key values. Can only be unbound with unbindALL()\n\n\t}, {\n\t\tkey: \"onNoteNumber\",\n\t\tvalue: function onNoteNumber(number, handler) {\n\t\t\treturn this.on(NOTE_ON_EVENT, function (data) {\n\t\t\t\tif (data.value == number) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"offNoteNumber\",\n\n\n\t\t// EZ binding for key values. Can only be unbound with unbindALL()\n\t\tvalue: function offNoteNumber(number, handler) {\n\t\t\treturn this.on(NOTE_OFF_EVENT, function (data) {\n\t\t\t\tif (data.value == number) {\n\t\t\t\t\thandler(data);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"keyToggleRange\",\n\n\n\t\t// EZ binding for a range of key values, bind these two handlers to key value. Can only be unbound with unbindALL()\n\t\tvalue: function keyToggleRange(min, max, onHandler, offHandler) {\n\t\t\treturn {\n\t\t\t\tonRange: this.onSplit(min, max, onHandler),\n\t\t\t\toffRange: this.offSplit(min, max, offHandler)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"onSplit\",\n\t\tvalue: function onSplit(min, max, onHandler) {\n\t\t\tvar on = [];\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\ton.push(this.onNoteNumber(i, onHandler));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i = max; _i >= min; _i--) {\n\t\t\t\t\ton.push(this.onNoteNumber(_i, onHandler));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn on;\n\t\t}\n\t}, {\n\t\tkey: \"offSplit\",\n\t\tvalue: function offSplit(min, max, offHandler) {\n\t\t\tvar off = [];\n\t\t\tif (max > min) {\n\t\t\t\tfor (var i = min; i <= max; i++) {\n\t\t\t\t\toff.push(this.onNoteNumber(i, offHandler));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var _i2 = max; _i2 >= min; _i2--) {\n\t\t\t\t\toff.push(this.onNoteNumber(_i2, offHandler));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn off;\n\t\t}\n\t}, {\n\t\tkey: \"unbindAll\",\n\n\n\t\t// Removes all bound events.\n\t\tvalue: function unbindAll() {\n\t\t\tthis.unBindKeyboard();\n\t\t\tfor (var event in this.listeners) {\n\t\t\t\tdelete this.listeners[event];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: \"bindKeyboard\",\n\t\tvalue: function bindKeyboard() {\n\t\t\tvar _this2 = this;\n\n\t\t\twindow.addEventListener(KEYBOARD_EVENT_KEY_DOWN, function (e) {\n\t\t\t\treturn _this2.keyboardKeyDown(e);\n\t\t\t});\n\t\t\twindow.addEventListener(KEYBOARD_EVENT_KEY_UP, function (e) {\n\t\t\t\treturn _this2.keyboardKeyUp(e);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"unBindKeyboard\",\n\t\tvalue: function unBindKeyboard() {\n\t\t\tvar _this3 = this;\n\n\t\t\twindow.removeEventListener(KEYBOARD_EVENT_KEY_DOWN, function (e) {\n\t\t\t\treturn _this3.keyboardKeyDown(e);\n\t\t\t});\n\t\t\twindow.removeEventListener(KEYBOARD_EVENT_KEY_UP, function (e) {\n\t\t\t\treturn _this3.keyboardKeyUp(e);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyDown\",\n\t\tvalue: function keyboardKeyDown(message) {\n\t\t\tif (KEY_CODE_MAP[message.keyCode] != undefined) {\n\t\t\t\tif (this.keyboadKeyPressed[message.keyCode] != true) {\n\t\t\t\t\tthis.keyboadKeyPressed[message.keyCode] = true;\n\t\t\t\t\tvar newMessage = Generate.NoteEvent(NOTE_ON_EVENT, KEY_CODE_MAP[message.keyCode]);\n\t\t\t\t\tif (newMessage !== null) {\n\t\t\t\t\t\tthis.sendMidiMessage(newMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"keyboardKeyUp\",\n\t\tvalue: function keyboardKeyUp(message) {\n\t\t\tif (KEY_CODE_MAP[message.keyCode] != undefined) {\n\t\t\t\tif (this.keyboadKeyPressed[message.keyCode] == true) {\n\t\t\t\t\tdelete this.keyboadKeyPressed[message.keyCode];\n\t\t\t\t\tvar newMessage = Generate.NoteEvent(NOTE_OFF_EVENT, KEY_CODE_MAP[message.keyCode]);\n\t\t\t\t\tif (newMessage !== null) {\n\t\t\t\t\t\tthis.sendMidiMessage(newMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"sendMidiMessage\",\n\t\tvalue: function sendMidiMessage(message) {}\n\t}]);\n\treturn MIDIEvents;\n}(Events);\n\nvar Mizzy = function (_MIDIEvents) {\n\tinherits(Mizzy, _MIDIEvents);\n\tcreateClass(Mizzy, null, [{\n\t\tkey: \"Generate\",\n\t\tget: function get$$1() {\n\t\t\treturn Generate;\n\t\t}\n\t}, {\n\t\tkey: \"NOTE_ON\",\n\t\tget: function get$$1() {\n\t\t\treturn NOTE_ON_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"NOTE_OFF\",\n\t\tget: function get$$1() {\n\t\t\treturn NOTE_OFF_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"CONTROLCHANGE\",\n\t\tget: function get$$1() {\n\t\t\treturn CONTROLLER_EVENT;\n\t\t}\n\t}, {\n\t\tkey: \"PITCHWHEEL\",\n\t\tget: function get$$1() {\n\t\t\treturn PITCHWHEEL_EVENT;\n\t\t}\n\t}]);\n\n\tfunction Mizzy() {\n\t\tclassCallCheck(this, Mizzy);\n\n\t\tvar _this = possibleConstructorReturn(this, (Mizzy.__proto__ || Object.getPrototypeOf(Mizzy)).call(this));\n\n\t\t_this.keysPressed = [];\n\t\t_this.midiAccess = null;\n\t\t_this.loopback = true;\n\n\t\t_this.boundInputs = [];\n\t\t_this.boundOutputs = [];\n\n\t\t_this.key = ENHARMONIC_KEYS[0]; // C-Major\n\n\t\tif (!window.MIDIMessageEvent) {\n\t\t\twindow.MIDIMessageEvent = function (name, params) {\n\t\t\t\t_this.name = name;\n\t\t\t\treturn Object.assign(_this, params);\n\t\t\t};\n\t\t}\n\n\t\treturn _this;\n\t}\n\n\tcreateClass(Mizzy, [{\n\t\tkey: \"initialize\",\n\t\tvalue: function initialize() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (this.midiAccess === null) {\n\t\t\t\tif (navigator.requestMIDIAccess) {\n\t\t\t\t\treturn navigator.requestMIDIAccess({\n\t\t\t\t\t\tsysex: false\n\t\t\t\t\t}).then(function (e) {\n\t\t\t\t\t\treturn _this2.onMIDISuccess(e);\n\t\t\t\t\t}, function (e) {\n\t\t\t\t\t\treturn _this2.onMIDIFailure(e);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"[Mizzy] Your browser does not support Web MIDI API. You can still use the local loopback however.\");\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setKey\",\n\t\tvalue: function setKey() {\n\t\t\tvar keyletter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"C\";\n\n\t\t\tthis.key = ENHARMONIC_KEYS[ENHARMONIC_KEYS.indexOf(keyletter.toUpperCase())] || \"C\";\n\t\t}\n\t}, {\n\t\tkey: \"getMidiInputs\",\n\t\tvalue: function getMidiInputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\treturn this.midiAccess.inputs.values();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getMidiOutputs\",\n\t\tvalue: function getMidiOutputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\treturn this.midiAccess.outputs.values();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"bindToInput\",\n\t\tvalue: function bindToInput(input) {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.boundInputs.push(input);\n\t\t\tinput.onmidimessage = function (e) {\n\t\t\t\treturn _this3.onMIDIMessage(e, _this3.key);\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"unbindInput\",\n\t\tvalue: function unbindInput(input) {\n\t\t\tvar index = this.boundInputs.indexOf(input);\n\t\t\tthis.boundInputs.slice(1, index);\n\t\t\tinput.onmidimessage = null;\n\t\t}\n\t}, {\n\t\tkey: \"bindToAllInputs\",\n\t\tvalue: function bindToAllInputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\tvar inputs = this.getMidiInputs();\n\t\t\t\tfor (var input = inputs.next(); input && !input.done; input = inputs.next()) {\n\t\t\t\t\tthis.bindToInput(input.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"unbindAllInputs\",\n\t\tvalue: function unbindAllInputs() {\n\t\t\tthis.boundInputs.forEach(this.unbindInput);\n\t\t}\n\t}, {\n\t\tkey: \"bindToOutput\",\n\t\tvalue: function bindToOutput(output) {\n\t\t\tthis.boundOutputs.push(output);\n\t\t}\n\t}, {\n\t\tkey: \"bindToAllOutputs\",\n\t\tvalue: function bindToAllOutputs() {\n\t\t\tif (this.midiAccess != null) {\n\t\t\t\tvar outputs = this.getMidiOutputs();\n\t\t\t\tfor (var output = outputs.next(); output && !output.done; output = outputs.next()) {\n\t\t\t\t\tthis.bindToOutput(output.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onMIDIFailure\",\n\t\tvalue: function onMIDIFailure(error) {\n\t\t\tthrow error;\n\t\t}\n\t}, {\n\t\tkey: \"onMIDISuccess\",\n\t\tvalue: function onMIDISuccess(midiAccessObj) {\n\t\t\tthis.midiAccess = midiAccessObj;\n\t\t}\n\t}, {\n\t\tkey: \"sendMidiMessage\",\n\t\tvalue: function sendMidiMessage(message) {\n\t\t\tthis.boundOutputs.forEach(function (output) {\n\t\t\t\toutput.send(message.data, message.timeStamp);\n\t\t\t});\n\t\t\tif (this.loopback) {\n\t\t\t\tthis.onMIDIMessage(message, this.key);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"keys\",\n\t\tget: function get$$1() {\n\t\t\treturn ENHARMONIC_KEYS;\n\t\t}\n\t}, {\n\t\tkey: \"outputDevices\",\n\t\tget: function get$$1() {\n\t\t\tvar deviceArray = [];\n\t\t\tvar devices = this.getMidiOutputs();\n\t\t\tfor (var input = devices.next(); input && !input.done; input = devices.next()) {\n\t\t\t\tdeviceArray.push(input.value);\n\t\t\t}\n\t\t\treturn deviceArray;\n\t\t}\n\t}, {\n\t\tkey: \"inputDevices\",\n\t\tget: function get$$1() {\n\t\t\tvar deviceArray = [];\n\t\t\tvar devices = this.getMidiInputs();\n\t\t\tfor (var input = devices.next(); input && !input.done; input = devices.next()) {\n\t\t\t\tdeviceArray.push(input.value);\n\t\t\t}\n\t\t\treturn deviceArray;\n\t\t}\n\t}]);\n\treturn Mizzy;\n}(MIDIEvents);\n\nmodule.exports = Mizzy;\n"],"file":"mizzy.cjs.js"}